## Управление контейнерами

- [Управление контейнерами](#container-management-1)
  - [Создание контейнера](#creating-a-container)
  - [Создание контейнеров с помощью hook-spec](#creating-containers-using-hook-spec)
  - [Настройка функции проверки состояния работоспособности при создании контейнера](#configuring-health-check-during-container-creation)
  - [Остановка и удаление контейнера](#stopping-and-deleting-a-container)
  - [Запрос информации о контейнере](#querying-container-information)
  - [Операции изменения](#modification-operations)

## Создание контейнера

### Загрузка образов

Команду **docker** может выполнять только пользователь с правами **root**. Если вход осуществляется от имени обычного пользователя, перед запуском команды **docker** необходимо выполнить команду **sudo**.

```
[root@localhost ~]# docker pull busybox
```

Эта команда используется для загрузки образа **busybox:latest** из официального регистра Docker. (Если в команде нет тега, используется имя тега по умолчанию **latest**.) Во время загрузки образа система проверяет локальное присутствие уровня зависимостей. Если такой уровень есть, шаг загрузки образа пропускается. При загрузке образов из частного регистра необходимо указать его описание. Например, если создается частный регистр, содержащий некоторые стандартные образы, и его IP-адресом является **192.168.1.110:5000**, для загрузки образа из частного регистра можно выполнить следующую команду:

```
[root@localhost ~]# docker pull 192.168.1.110:5000/busybox
```

Имя образа, загруженного из частного регистра, содержит информацию об адресе этого регистра, и длина имени может быть слишком большой. Команда **docker tag** создает образ с коротким именем.

```
[root@localhost ~]# docker tag 192.168.1.110:5000/busybox busybox
```

С помощь команды **docker images** осуществляется просмотр списка локальных образов.

### Запуск простого приложения

```
[root@localhost ~]# docker run busybox /bin/echo "Hello world"
Hello world
```

Эта команда создает контейнер с помощью образа **busybox:latest** и выполняет в контейнере команду **echo "Hello world"**. Просмотр созданного контейнера выполняется следующей командой:

```
[root@localhost ~]# docker ps -l
CONTAINER ID        IMAGE               COMMAND                   CREATED             STATUS                     PORTS               NAMES
d8c0a3315bc0        busybox"/bin/echo 'Hello wo..."   5 seconds ago       Exited (0) 3 seconds ago                       practical_franklin
```

### Создание контейнера для интерактивного доступа

```
[root@localhost ~]# docker run -it busybox /bin/bash
root@bf22919af2cf:/# ls 
bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var 
root@bf22919af2cf:/# pwd 
/
```

С помощью параметра **-ti** контейнеру выделяется псевдотерминал, и для интерактивного доступа используется стандартный ввод (STDIN). В этом случае в контейнере можно запускать команды. Созданный таким образом контейнер является независимой виртуальной машиной Linux. Командой **exit** выполняется выход из контейнера.

### Запуск контейнера в работу в фоновом режиме

Выполните следующую команду. **-d** означает, что контейнер работает в фоновом режиме. 
**--name=container1** означает, что именем контейнера является **container1**.

```
[root@localhost ~]# docker run -d --name=container1 busybox /bin/sh -c "while true;do echo hello world;sleep 1;done"
7804d3e16d69b41aac5f9bf20d5f263e2da081b1de50044105b1e3f536b6db1c
```

Вывод команды содержит идентификатор контейнера, но не содержит информацию **hello world**. В этом случае контейнер работает в фоновом режиме. Просмотр работающего контейнера осуществляется командой **docker ps**.

```
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
7804d3e16d69        busybox "/bin/sh -c 'while tr"   11 seconds ago      Up 10 seconds                           container1
```

Выполните команду **docker logs** следующим образом, чтобы просмотреть вывод во время работы контейнера:

```
[root@localhost ~]# docker logs container1
hello world
hello world
hello world
...
```

### Сетевое соединение контейнера

По умолчанию контейнер может получать доступ к внешней сети, а чтобы внешняя сеть получила доступ к контейнеру, необходима настройка соответствия портов. Далее приведен пример запуска службы частного регистра в Docker. В следующей команде **-P** используется для предоставления открытых портов в регистре хосту.

```
[root@localhost ~]# docker run --name=container_registry -d -P registry 
cb883f6216c2b08a8c439b3957fb396c847a99079448ca741cc90724de4e4731 
```

Данной командой запущен контейнер container\_registry, но без четкого соответствия между службами в контейнере и портами хоста. Необходимо выполнить команду **docker port**, чтобы просмотреть информацию о соответствии портов.

```
[root@localhost ~]# docker port container_registry 
5000/tcp -> 0.0.0.0:49155 
```

Вывод команды показывает, что порт 5000 в контейнере соответствует порту 49155 на хосте. Доступ к службе регистра можно получить, используя IP-адрес хоста **49155**. Введите **http://localhost:49155** в адресном поле браузера и нажмите **Enter**. Появится информация о версии регистра.

Соответствие портов можно указать сразу при запуске образов регистра, как показано в следующем примере:

```
docker run --name=container_registry -d -p 5000:5000 registry 
```

**-p 5000:5000** используется для сопоставления порта 5000 в контейнере с портом 5000 на хосте.

### Меры предосторожности

- **-a stdin отдельно не добавляется во время запуска контейнера**
  
  При запуске контейнера необходимо добавить **-a stdout** или **-a stderr** вместе с **-a stdin**, а не просто отдельный **-a stdin**. В противном случае устройство прекращает отвечать даже после завершения работы контейнера.

- **Нельзя использовать длинный или короткий идентификатор существующего контейнера в качестве имени нового контейнера**
  
  При создании контейнера не используйте длинный или короткий идентификатор существующего контейнера A в качестве имени нового контейнера B. Если длинный идентификатор контейнера A используется в качестве имени контейнера B, Docker будет соответствовать контейнеру A, даже если имя контейнера B используется в качестве указанного для выполнения операций контейнера. Если в качестве имени контейнера B используется короткий идентификатор контейнера A, Docker соответствует контейнеру B, даже если короткий идентификатор контейнера A используется в качестве указанного для выполнения операций контейнера. Это происходит в связи с тем, что Docker сначала сопоставляет длинные идентификаторы всех контейнеров. В случае ошибки сопоставления, система выполняет операцию точного сопоставления с использованием значения **container\_name**. Если ошибка сопоставления не устраняется, идентификатор контейнера сопоставляется непосредственно в режиме нечеткого соответствия.

- **Во избежание ошибок в контейнерах, которые зависят от стандартного ввода и вывода, например sh/bash, должен использоваться параметр -ti**
  
  Нормальный сценарий: если параметр **-ti** для запуска такого обрабатывающего контейнера, как sh/bash, не используется, контейнер немедленно завершает работу.
  
  Причина этой проблемы заключается в том, что Docker сначала создает stdin, который сопоставляет службы в контейнере. Если интерактивные параметры, такие как **-ti**, не установлены, Docker завершает системный вызов pipe после запуска контейнера, а процесс служебного контейнера sh/bash завершается после завершения stdin.
  
  Сценарий с ошибкой: если демон Docker принудительно аннулируется на определенном этапе (до завершения системного вызова pipe), демон pipe своевременно не завершается. В этом случае процесс sh/bash не завершается даже без параметра **-ti.** В результате возникает ошибка. Необходимо вручную выполнить сброс контейнера.
  
  После перезапуска демон переходит на исходный поток контейнера. Есть вероятность, что контейнеры, не имеющие параметра **-ti**, не смогут обработать данный поток, поскольку такие контейнеры не имеют потоков, на которые можно перейти в обычной ситуации. В реальных службах sh/bash без параметра **-ti** не вступает в силу и редко используется. Чтобы избежать этой проблемы, используется параметр **-ti**, который ограничивает интерактивный доступ к контейнерам.

- **Тома хранения контейнеров**
  
  Если при запуске контейнера используется параметр **-v** для монтирования файлов, размещенных на хосте, к контейнеру, возможно, что в результате изменения файлов на хосте или в контейнере командой **vi** или **sed** изменятся индексные дескрипторы (inodes). В результате файлы на хосте и в контейнере не будут синхронизированы. Поэтому в этом режиме файлы в контейнере не монтируют (и не используют вместе с командами **vi** и **sed**). Избежать ошибок можно также, смонтировав каталоги верхнего уровня файлов. Параметр **nocopy** используется для предотвращения копирования исходных файлов, содержащихся в каталогах точки монтирования контейнера, в исходный каталог хоста во время монтирования томов через Docker. Однако этот параметр можно использовать только для монтирования анонимного тома и нельзя использовать в сценарии монтирования с привязкой.

- **Не используйте параметры, которые могут повлиять на состояние хоста**
  
  Параметр **--privileged** позволяет получить все разрешения на операции с контейнером. В контейнере доступны операции монтирования и изменения таких каталогов, как **/proc** и **/sys**, которые могут повлиять на состояние хоста. Не используйте этот параметр для обычных контейнеров.
  
  Также на работу хоста может повлиять использование контейнером общего с хостом пространства имен, что задается параметром **--pid host**, **--ipc host** или **--net host**. Поэтому не используйте эти параметры.

- **Не используйте нестабильную версию cgroup памяти ядра**
  
  Контрольная группа (cgroup) памяти ядра Linux версии ранее 4.0 пока еще находится в стадии пробного использования и работает нестабильно. Поэтому не используйте эту версию cgroup памяти ядра.
  
  При выполнении команды **docker run --kernel-memory** генерируется следующий аварийный сигнал:
  
  ```
  WARNING: You specified a kernel memory limit on a kernel older than 4.0. Kernel memory limits are experimental on older kernels, it won't work as expected as expected and can cause your system to be unstable.
  ```

- **Параметр blkio-weight недоступен в ядрах, поддерживающих точный контроль blkio**
  
  **--blkio-weight-device** реализует более точный контроль blkio в контейнере. Для данного вида контроля требуется указанное дисковое устройство, которое может быть реализовано с помощью параметра **--blkio-weight-device** в Docker. В этом ядре Docker не предоставляет режим **--blkio-weight** для ограничения метрик blkio контейнера. При использовании этого параметра для создания контейнера передается следующая ошибка:
  
  ```
  docker: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused "process_linux.go:398: container init caused \"process_linux.go:369: setting cgroup config for ready process caused \\\"blkio.weight not supported, use weight_device instead\\\"\""
  ```

- **Использование --blkio-weight-device в политике планирования CFQ**
  
  Параметр **--blkio-weight-device** работает только тогда, когда диск работает в соответствии с политикой полностью справедливого обслуживания в очереди (Completely Fair Queuing; CFQ).
  
  Для получения информации о политиках, поддерживаемых диском, и текущей политике, можно просмотреть файл планировщика (**/sys/block/**_disk_**/queue/scheduler**). Например, просмотр **sda** выполняется следующей командой.
  
  ```
  # cat /sys/block/sda/queue/scheduler noop [deadline] cfq 
  ```
  
  **sda** поддерживает следующие политики планирования: **noop**, **deadline**, **cfq**. В примере используется политика **deadline**. Командой **echo** выполняется изменение политики, например на **cfq**.
  
  ```
  # echo cfq > /sys/block/sda/queue/scheduler
  ```

- **Ограничения использования systemd в базовых образах контейнера**
  
  При использовании контейнеров, созданных на основе базовых образов, systemd в таких образах используется только для системных контейнеров.

### Производительность параллельно выполняемых операций

- В Docker существует верхний предел для буфера сообщений. В условии превышения количеством сообщений установленного верхнего предела новые сообщения отбрасываются. Поэтому рекомендуется, чтобы количество параллельно выполняемых команд не превышало 1000. В противном случае есть вероятность потери внутренних сообщений в Docker и ошибки запуска контейнера.
- При одновременном создании и перезапуске контейнеров иногда передается ошибка «oci runtime error: container init still running». Это связано с тем, что containerd оптимизирует производительность очереди ожидания событий. При остановке контейнера выполняется команда **runc delete**, чтобы аннулировать процессы init в контейнере в течение 1 секунды. Если процессы init не аннулируются через 1 секунду, runC возвращает это сообщение об ошибке. Механизм сборки мусора (Garbage Collection; GC) containerd высвобождает остаточные ресурсы памяти после выполнения команды **runc delete** с интервалом 10 секунд. Поэтому операции на контейнере не затрагиваются. При возникновении данной ошибки подождите 4-5 секунд и перезапустите контейнер.

### Интерпретация функций безопасности

1. Далее описан анализ конфигурации разрешений Docker по умолчанию.
   
   В конфигурации по умолчанию для native Docker функции каждого процесса по умолчанию следующие:
   
   ```
   "CAP_CHOWN", 
   "CAP_DAC_OVERRIDE", 
   "CAP_FSETID", 
   "CAP_FOWNER", 
   "CAP_MKNOD", 
   "CAP_NET_RAW", 
   "CAP_SETGID", 
   "CAP_SETUID", 
   "CAP_SETFCAP", 
   "CAP_SETPCAP", 
   "CAP_NET_BIND_SERVICE", 
   "CAP_SYS_CHROOT", 
   "CAP_KILL", 
   "CAP_AUDIT_WRITE",
   ```
   
   Конфигурация seccomp по умолчанию — белый список. Если какой-либо системный вызов не входит в белый список, по умолчанию возвращается ошибка **SCMP\_ACT\_ERRNO**. Для разных функций Docker инициируется соответствующая система. Если какая-либо из функций не входит в белый список, Docker по умолчанию не назначает ее контейнеру.

2. CAP\_SYS\_MODULE
   
   С помощью CAP\_SYS\_MODULE контейнер вставляет модуль ko. Добавление данной функции может привести к атаке выхода из контейнера (container escape) или даже повреждению ядра. Пространство имен обеспечивает максимальную изоляцию контейнера. В модуле ko необходимо указывать только его пространство имен, добавленное к объекту init\_nsproxy.

3. CAP\_SYS\_ADMIN
   
   С полномочиями sys\_admin доступны следующие функции для контейнера:
   
   - Для файловой системы: **mount**, **umount**, **quotactl**
   - Для настройки пространства имен: **setns**, **unshare**, **clone new namespace**
   - ioctl драйвера
   - Для управления PCI: **pciconfig\_read**, **pciconfig\_write**, **pciconfig\_iobase**
   - **sethostname**

4. CAP\_NET\_ADMIN
   
   CAP\_NET\_ADMIN позволяет контейнеру получать доступ к сетевым интерфейсам и перехватывать (sniff) сетевой трафик. Контейнер может перехватить сетевой трафик всех контейнеров, включая хост, что наносит серьезный урон безопасности сети.

5. CAP\_DAC\_READ\_SEARCH
   
   CAP\_DAC\_READ\_SEARCH выполняет системные вызовы open\_by\_handle\_at и name\_to\_handle\_at. Если хост не защищен посредством SELinux, контейнер может методом полного перебора дескрипторов inode структуры file\_handle открыть любой файл на хосте, что негативно отражается на изоляции файловой системы.

6. CAP\_SYS\_RAWIO
   
   CAP\_SYS\_RAWIO позволяет контейнеру записывать порты ввода-вывода на хост, что может привести к сбою ядра хоста.

7. CAP\_SYS\_PTRACE
   
   С разрешением ptrace становится доступна функция отладки процесса ptrace. В RunC данная уязвимость устранена. Однако некоторые инструменты, такие как nsenter и docker-enter, не имеют защиты. В контейнере процессы, выполняемые этими инструментами, могут пройти отладку с целью получения информации о ресурсах (например, о пространстве имен и fd), передаваемой этими инструментами. Кроме того, ptrace может обойти защиту seccomp, значительно повышая риск атаки на ядро.

8. Интерфейс с возможностями Docker: --cap-add all
   
   --cap-add all выдает все разрешения контейнеру, включая упомянутые в этом разделе опасные разрешения, что создает условия для атаки выхода из контейнера (container escape).

9. Не отключайте функцию seccomp контейнера Docker.
   
   Docker имеет конфигурацию seccomp по умолчанию с белым списком. **sys\_all**, не входящие в белый список, отключаются механизмом защиты seccomp. Функция seccomp отключается командой **--security-opt 'seccomp:unconfined'**. Если функция seccomp отключена или используется конфигурация seccomp, определяемая пользователем, но список фильтрации неполон, риск атаки на ядро в контейнере повышается.

10. Не устанавливайте разрешение на запись для каталогов **/sys** и **/proc**.
    
    Каталоги **/sys** и **/proc** содержат параметры техобслуживания ядра Linux и интерфейсы управления устройствами. Если для этих каталогов в контейнере настроено разрешение на запись, появляется вероятность атаки выхода из контейнера.

11. Возможность открытия контейнера Docker: --CAP\_AUDIT\_CONTROL
    
    Данное разрешение позволяет контейнеру управлять системой аудита и запускать команды **AUDIT\_TTY\_GET** и **AUDIT\_TTY\_SET** для получения записей исполнения абстракции TTY (включая пароль пользователя **root**), записанных в системе аудита.

12. CAP\_BLOCK\_SUSPEND и CAP\_WAKE\_ALARM
    
    С помощью данного разрешения контейнер может блокировать процесс приостановки системы (epoll).

13. CAP\_IPC\_LOCK
    
    Посредством данного разрешения контейнер может обойти максимальный предел заблокированной памяти, заданный параметром **ulimit**, и использовать любой большой блок памяти mlock для вызова DoS-атак.

14. CAP\_SYS\_LOG
    
    В контейнере с таким разрешением журналы системного ядра могут считываться с помощью dmesg с целью обхода защиты ядра kaslr.

15. CAP\_SYS\_NICE
    
    В контейнере с этим разрешением возможны изменения политики планирования и приоритет процесса, что может стать причиной DoS-атак.

16. CAP\_SYS\_RESOURCE
    
    С помощью этого разрешения контейнер обходит ограничения ресурсов, например ограничение ресурсов на диске, ограничение по раскладкам клавиатуры и ограничение размера **pipe-size-max**, что вызывает DoS-атаки.

17. CAP\_SYS\_TIME
    
    В контейнере с этой возможностью можно изменить время на хосте.

18. Анализ рисков возможностей по умолчанию контейнера Docker
    
    Возможности Docker по умолчанию: CAP\_SETUID и CAP\_FSETID. Если хост и контейнер используют один каталог, контейнер может установить разрешения для бинарного файла в таком общем каталоге. Обычные пользователи на хосте могут использовать этот способ для повышения уровня разрешений. С помощью функции CAP\_AUDIT\_WRITE контейнер может записывать журналы на хост, а для хоста должен быть сконфигурирован механизм защиты журнала от переполнения.

19. Docker и хост используют одни параметры пространствва имен, такие как **--pid**, **--ipc**, **--uts**.
    
    Эти параметры определяют, что контейнер и хост имеют общее пространство имен. Из-за того, что пространство имен контейнера не изолировано от пространства имен хоста, контейнер может атаковать хост. Например, если посредством параметра **--pid** задается использование общего с хостом пространства имен PID, данный PID на хосте доступен для просмотра с контейнера. Также становится доступной возможность аннулирования процессов на хосте.

20. Параметр **--device** используется для сопоставления конфиденциальных каталогов или устройств хоста с контейнером.
    
    В плоскости управления Docker предоставляются интерфейсы для сопоставления каталогов или устройств на хосте с контейнером, например **--device** и **-v**. Не сопоставляйте конфиденциальные каталоги или устройства на хосте с контейнером.

## Создание контейнеров с помощью hook-spec

### Принципы и сценарии применения

Контейнер Docker поддерживает расширенные спецификации перехвата (hook). Выполнение приложений перехвата и соответствующего runC отвечает стандартам OCI. Для получения подробной информации о стандартах перейдите на страницу [https://github.com/opencontainers/runtime-spec/blob/master/config.md#hooks](#https://github.com/opencontainers/runtime-spec/blob/master/config.md#hooks).

Существует три типа перехвата: перед стартом, после старта и после остановки. Они применяются соответственно до запуска приложений в контейнере, после запуска приложений в контейнере и после остановки приложений.

### Справочная информация по API

Параметр **--hook-spec** добавляется к командам **docker run** и **create**, за которыми следует абсолютный путь к файлу **spec**. Пользователь может указать перехваты (hooks), которые требуется добавить при запуске контейнера. Эти перехваты будут автоматически добавляться после перехватов, динамически создаваемых контейнером Docker (в настоящее время доступен только перехват libnetwork prestart hook) для выполнения программ, указанных пользователями во время запуска или аннулирования контейнера.

Структура файла **spec** следующая:

```
// Hook specifies a command that is run at a particular event in the lifecycle of a container
type Hook struct{       
               Path    string   `json:"path"`    
               Args    []string `json:"args,omitempty"`    
               Env     []string `json:"env,omitempty"`      
               Timeout *int     `json:"timeout,omitempty"`
}
// Hooks for container setup and teardown
type  Hooks struct{
               // Prestart is a list of hooks to be run before the container process is executed.
               // On Linux, they are run after the container namespaces are created.         
               Prestart []Hook `json:"prestart,omitempty"`
               // Poststart is a list of hooks to be run after the container process is started.         
               Poststart []Hook `json:"poststart,omitempty"`
               // Poststop is a list of hooks to be run after the container process exits.         
               Poststop []Hook `json:"poststop,omitempty"`
}
```

- Параметры **Path, Args** и **Env** являются обязательными.
- **Timeout** — необязательный параметр, но его рекомендуется установить, задав значение в диапазоне от 1 до 120. Тип параметра — целое число. Числа с плавающей запятой не допускаются.
- Содержимое файла **spec** должно быть в формате JSON, как показано в предыдущем примере. Если формат неверен, передается ошибка.
- Можно использовать оба формата — **docker run --hook-spec /tmp/hookspec.json** _**xxx**_ и **docker create --hook-spec /tmp/hookspec.json **_xxx_** \&\& docker start** _**xxx**_.

### Настройка перехватов для контейнера

В качестве примера здесь приведена операция добавления NIC во время запуска. Содержимое файла **hook spec**:

```
{
    "prestart": [
         {
             "path": "/var/lib/docker/hooks/network-hook",             
             "args": ["network-hook", "tap0", "myTap"],             
             "env": [],
             "timeout": 5
         }
     ],
     "poststart":[],     
     "poststop":[]
}
```

Для добавления конфигурации сетевого перехвата укажите перехват перед стартом. Путь — **/var/lib/docker/hooks/network-hook**. **args** — это параметры программы. Как правило, первым параметром является имя программы, а вторым— параметр, принятый программой. Для программы network-hook требуются два параметра. Один из них — это имя NIC на хосте, а второй — имя NIC в контейнере.

  

- Меры предосторожности
  
  1. Путь **hook** должен находиться в папке **hooks** или каталоге **graph** (**--graph**) контейнера Docker. Его значение по умолчанию — **/var/lib/docker/hooks**. Просмотр корневого пути осуществляется командой **docker info**.
     
     ```
     [root@localhost ~]# docker info 
     ... 
     Docker Root Dir: /var/lib/docker 
     ...
     ```
     
     Этот путь пользователь может изменить вручную и с использованием пространства имен пользователя (**daemon --userns-remap**). После анализа символической ссылки данного пути анализируемый путь должен начинаться с _Docker Root Dir_**/hooks** (например, **/var/lib/docker/hooks**). В противном случае на экране появится сообщение об ошибке.
  
  2. Путь **hook** должен быть абсолютным, поскольку демон не способен корректно обрабатывать относительные пути. Кроме того, абсолютный путь отвечает требованиям безопасности.
  
  3. Информация, генерируемая программой hook для stderr, выводится клиенту и влияет на жизненный цикл контейнера (например, возможен сбой запуска контейнера). Информация, выводимая в stdout, игнорируется.
  
  4. В перехватах нельзя выполнять обратный вызов команд контейнера Docker.
  
  5. В сконфигурированном исполняющем файле перехвата должно быть выдано разрешение на выполнение. В противном случае при выполнении перехвата передается ошибка.
  
  6. Время выполнения операции перехвата должно быть максимально маленьким. Если период перед запуском слишком длинный (более 2 минут), возникает таймаут запуска контейнера. Если период после запуска слишком длинный (более 2 минут), контейнер в состоянии сбоя.
     
     Известные ошибки. Если для остановки контейнера выполняется команда **docker stop**, и через 2 минуты выполняется операция сброса, операция перехвата еще не завершена. Поэтому система ожидает завершения операции перехвата (процесс поддерживает блокировку). В результате все операции, связанные с контейнером, прекращают отвечать. Операции можно восстановить только после завершения операции перехвата. Кроме того, двухминутная обработка таймаута команды **docker stop** представляет собой асинхронный процесс. Поэтому, даже если команда **docker stop** будет успешно выполнена, контейнер останется в состоянии **up**. Контейнер перейдет в состояние **exited** только после завершения операции перехвата.

- Рекомендации
  
  1. Рекомендуется установить порог времени ожидания перехвата в значение менее 5 с.
  2. Рекомендуется настроить для каждого контейнера только один перехват перед стартом, один после старта и один после остановки. Если настроить слишком много перехватов, запуск контейнера может занять много времени.
  3. Между несколькими перехватами рекомендуется определить зависимости. При необходимости в соответствии с зависимостями настраивается последовательность конфигурационных файлов перехвата. Последовательность выполнения перехвата будет осуществляться согласно последовательности в сконфигурированном файле **spec**.

### Несколько перехватов с использованием параметра **hook-spec**

Если доступны несколько конфигурационных файлов перехвата и требуется запустить несколько перехватов, необходимо вручную объединить эти файлы в один конфигурационный файл и указать новый конфигурационный файл с помощью параметра **--hook-spec.** В этом случае все перехваты вступят в силу. Если настроены несколько параметров **--hook-spec**, вступает в силу только последний.

Пример настройки:

Содержимое файла **hook1.json**:

```
# cat /var/lib/docker/hooks/hookspec.json 
{
    "prestart": [
        {
            "path": "/var/lib/docker/hooks/lxcfs-hook",             
            "args": ["lxcfs-hook", "--log", "/var/log/lxcfs-hook.log"],             
            "env": []
        }
     ],     
     "poststart":[],     
     "poststop":[]
}
```

Содержимое файла **hook2.json**:

```
# cat /etc/isulad-tools/hookspec.json 
{
      "prestart": [
         {
               "path": "/docker-root/hooks/docker-hooks",             
               "args": ["docker-hooks", "--state", "prestart"],             
               "env": []
         }
       ],     
       "poststart":[],     
       "poststop":[
          {
               "path": "/docker-root/hooks/docker-hooks",             
               "args": ["docker-hooks", "--state", "poststop"],             
               "env": []
          }
        ]
}
```

Содержимое файла в формате JSON после ручной операции объединения будет следующим:

```
{
       "prestart":[
          {
                "path": "/var/lib/docker/hooks/lxcfs-hook",             
                "args": ["lxcfs-hook", "--log", "/var/log/lxcfs-hook.log"],             
                "env": []
           },         
           {
                "path": "/docker-root/hooks/docker-hooks",             
                "args": ["docker-hooks", "--state", "prestart"],             
                "env": []
           }
        ],     
        "poststart":[],     
        "poststop":[
            {
                "path": "/docker-root/hooks/docker-hooks",             
                "args": ["docker-hooks", "--state", "poststop"],             
                "env": []
            }
         ]
}
```

Демон Docker последовательно считывает двоичные значения команды перехвата перед стартом из конфигурационного файла перехвата на основе последовательности массива и выполняет требуемые действия. Поэтому между несколькими перехватами рекомендуется определить зависимости. При необходимости в соответствии с зависимостями настраивается последовательность конфигурационных файлов перехвата.

### Настройка перехватов по умолчанию для всех контейнеров

Демон Docker может получать параметр **--hook-spec.** Семантика **--hook-spec** совпадает с семантикой **--hook-spec** в **docker create** или **docker run**. Настройки перехвата также можно добавить в файл **/etc/docker/daemon.json**.

```
{
     "hook-spec": "/tmp/hookspec.json"
}
```

Когда контейнер работает, сначала выполняются перехваты, указанные в **--hook-spec**, определенных демоном, а затем перехваты, настроенные для каждого контейнера.

## Настройка функции проверки состояния работоспособности при создании контейнера

Docker предоставляет функцию проверки состояния работоспособности контейнеров, определяемую пользователем. При создании контейнера настраивается опция **HEALTHCHECK CMD** в файле Dockerfile или опция **--health-cmd**, чтобы в контейнере периодически выполнялись команды мониторинга его состояния работоспособности на основе возвращаемых функцией значений.

### Методы настройки

- Добавьте следующую информацию в файл Dockerfile:
  
  ```
  HEALTHCHECK --interval=5m --timeout=3s --health-exit-on-unhealthy=true \
     CMD curl -f http://localhost/ || exit 1
  ```
  
  Настраиваемые параметры:
  
  1. **--interval=DURATION:** интервал между двумя последовательными выполнениями команды. Значение по умолчанию — **30s**. После запуска контейнера первая проверка выполняется через данный интервал.
  
  2. **--timeout=DURATION**: максимальная продолжительность выполнения одной команды проверки. По истечении времени ожидания выполнения команда завершается с неуспешным результатом. Значение по умолчанию — **30s**.
  
  3. **--start-period=DURATION**: период инициализации контейнера. Значение по умолчанию — **0s**. Во время инициализации также проводится проверка состояния работоспособности, при этом неуспешно завершенные проверки не учитываются счетчиком максимального количества повторных попыток. Однако, если проверка работоспособности во время инициализации завершается успешно, контейнер считается запущенным. Все последующие сбои последовательной проверки учитываются счетчиком максимального количества повторных попыток.
  
  4. **--retries=N**: максимальное количество повторных попыток проверки состояния работоспособности. Значение по умолчанию — **3**.
  
  5. **--health-exit-on-unhealthy\=BOOLEAN**: параметр определяет, требуется ли аннулировать контейнер в случае его нерабочего состояния. Значение по умолчанию — **false**.
  
  6. **CMD**: данный параметр обязателен. Если после запуска команды в контейнере возвращается значение **0**, команда успешно выполняется. Если возвращается другое значение, значит, произошел сбой выполнения команды.
     
     После настройки параметра **HEALTHCHECK** в конфигурацию образа во время его создания вносятся соответствующие настройки. Просмотр настроек осуществляется командой **docker inspect**. Пример:
     
     ```
     "Healthcheck": {
         "Test": [
             "CMD-SHELL",
             "/test.sh"
         ]
     },
     ```

- Настройка при запуске контейнера:
  
  ```
  docker run -itd --health-cmd "curl -f http://localhost/ || exit 1" --health-interval 5m --health-timeout 3s --health-exit-on-unhealthy centos bash
  ```
  
  Настраиваемые параметры:
  
  1. **--health-cmd**: данный параметр обязателен. Если после запуска команды в контейнере возвращается значение **0**, команда успешно выполняется. Если возвращается другое значение, значит, произошел сбой выполнения команды.
  
  2. **--health-interval:** интервал между двумя последовательными выполнениями команды. Значение по умолчанию — **30s**. Верхний предел значения — это максимальное значение Int64 (единица измерения: наносекунда).
  
  3. **--health-timeout**: максимальная продолжительность выполнения одной команды проверки. По истечении времени ожидания выполнения команда завершается с неуспешным результатом. Значение по умолчанию — **30s**. Верхний предел значения — это максимальное значение Int64 (единица измерения: наносекунда).
  
  4. **--health-start-period**: время инициализации контейнера. Значение по умолчанию — **0s**. Верхний предел значения — это максимальное значение Int64 (единица измерения: наносекунда).
  
  5. **--health-retries**: максимальное количество повторов для проверки состояния работоспособности. Значение по умолчанию — **3**. Максимальное значение равно максимальному значению Int32.
  
  6. **--health-exit-on-unhealthy**: параметр определяет, требуется ли аннулировать контейнер в случае его нерабочего состояния. Значение по умолчанию — **false**.
     
     После запуска контейнера настройки **HEALTHCHECK** вносятся в конфигурацию контейнера. Просмотр настроек осуществляется командой **docker inspect**. Пример:
     
     ```
     "Healthcheck": {
         "Test": [
             "CMD-SHELL",
             "/test.sh"
         ]
     },
     ```

### Правила проверки

1. После запуска контейнер имеет статус **health:starting**.
2. После настройки времени **start-period** команда **cmd** будет периодически выполняться в контейнере с интервалом, заданным параметром **interval**. То есть, после завершения выполнения данная команда будет исполнена повторно через указанный интервал времени.
3. Проверка считается успешно выполненной при условии успешного завершения выполнения команды **cmd** в течение времени, заданного параметром **timeout**, и возврата функцией значения **0**. В противном случае произойдет сбой проверки. После успешного завершения проверки контейнер получает статус **health:healthy**.
4. Если команда **cmd** не выполняется заданное параметром **retries** количество раз, контейнер получает **статус health:unhealthy** и продолжает проверку состояния работоспособности.
5. Контейнер меняет статус **health:unhealthy** на статус **health:healthy** при успешном завершении проверки.
6. Если установлен параметр **--health**--**exit-on-unhealthy**, и контейнер завершает работу по другим причинам, а не в связи с аннулированием (возвращаемый код завершения работы — **137**), проверка состояния работоспособности возобновляется только после повторного запуска контейнера.
7. По завершении выполнения команды **cmd** или наступлении тайм-аута демон Docker вносит время начала выполнения, возвращенное функцией значение и стандартный результат проверки в конфигурационный файл контейнера. Вносятся максимум последние пять записей. Кроме того, в конфигурационном файле контейнера хранятся параметры проверки работоспособности.

Просмотр состояния контейнера осуществляется командой **docker ps**.

```
[root@bac shm]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                         PORTS               NAMES
7de2228674a2        testimg             "bash"              About an hour ago   Up About an hour (unhealthy)                       cocky_davinci
```

Когда контейнер работает, статус проверки работоспособности записывается в конфигурацию контейнера. Просмотр настроек осуществляется командой **docker inspect**.

```
"Health": {
    "Status": "healthy",
    "FailingStreak": 0,
    "Log": [
        {
            "Start": "2018-03-07T07:44:15.481414707-05:00",
            "End": "2018-03-07T07:44:15.556908311-05:00",
            "ExitCode": 0,
            "Output": ""
        },
        {
            "Start": "2018-03-07T07:44:18.557297462-05:00",
            "End": "2018-03-07T07:44:18.63035891-05:00",
            "ExitCode": 0,
            "Output": ""
        },
        ......
}
```

> ![](./public_sys-resources/icon-note.gif) **ПРИМЕЧАНИЕ:**
> 
> - В контейнере могут храниться максимум пять записей о состоянии проверки работоспособности. Хранятся последние пять записей.
> - В один момент времени в силу может вступить только один элемент конфигурации проверки работоспособности. Последние настроенные в файле Docker элементы перезаписывают предыдущие. Настройки, сконфигурированные при создании контейнера, перезаписывают такие же настройки в образах.
> - В файле Docker можно установить параметр **HEALTHCHECK NONE**, который отменяет проверку работоспособности в указанном образе. Проверку работоспособности в указанном образе можно отменить во время работы контейнера установкой параметра **--no-healthcheck**. Не настраивайте параметры проверки работоспособности и **--no-healthcheck** одновременно во время запуска.
> - Если после запуска контейнера с настроенными параметрами проверки работоспособности демон Docker завершает работу, проверка работоспособности не выполняется. После запуска демон Docker переходит в статус **starting**. После этого применяются вышеперечисленные правила проверки.
> - Если параметрам проверки работоспособности задано значение **0** во время создания образа контейнера, используются значения по умолчанию.
> - Если параметрам проверки работоспособности задано значение **0** во время запуска контейнера, используются значения по умолчанию.

## Остановка и удаление контейнера

Команда **docker stop** в следующем примере останавливает контейнер под именем **container1**.

```
[root@localhost ~]# docker stop container1
```

Остановить и удалить контейнер можно также командой **docker kill**.

```
[root@localhost ~]# docker kill container1
```

Остановив контейнер, выполните команду **docker rm**, чтобы его удалить.

```
[root@localhost ~]# docker rm container1
```

Принудительно удалить контейнер можно также командой **docker rm -f**.

```
[root@localhost ~]# docker rm -f container1
```

### Меры предосторожности

- Не удаляйте контейнер командой **docker rm -f** *XXX*. При принудительном удалении контейнера команда **docker rm** игнорирует ошибки в процессе, что может стать причиной остаточных метаданных контейнера. Если ошибка возникает во время удаления образа в обычном режиме, удаление не выполняется, и метаданные не остаются.
- Не выполняйте команду **docker kill**. Команда **docker kill** отправляет соответствующие сигналы служебным процессам в контейнере. В зависимости от политики обработки сигналов, принятой в служебных процессах контейнера, такие сигналы не будут обработаны должным образом.
- Находящийся в состоянии перезапуска контейнер не может остановиться немедленно в ответ на запрос команды **docker stop**. Если контейнер использует правила перезапуска, находясь в состоянии перезапуска, маловероятен быстрый отклик на команду **docker stop,** выполненную в контейнере. Контейнер будет повторно запущен согласно правилу перезапуска.
- Не перезапускайте контейнер командой **docker restart** с параметром **--rm.** При завершении работы контейнера с параметром **--rm** контейнер автоматически удаляется. При перезапуске контейнера с параметром -**-rm** возможно появление ошибок. Например, если при запуске контейнера добавляются оба параметра -**-rm** и **-ti**, операция перезапуска на контейнере невозможна, иначе контейнер прекращает отвечать и не может завершить работу.

### Задавая параметры -t и t\<0 для остановки или перезапуска Docker, убедитесь, что приложения в контейнере могут обрабатывать сигнал остановки

Принцип совершения остановки: (Процесс остановки инициируется командой **Restart**.)

1. Сначала в контейнер посылается сигнал SIGTERM (15).
2. Система ожидает в течение указанного времени (параметр **t** задается пользователем).
3. Если процесс контейнера все еще существует, отправляется сигнал SIGKILL (9), чтобы принудительно его остановить.

Значение вводимого параметра **t** (единица измерения: секунда) следующее:

- **t** \< 0: ожидание постепенной остановки. Эта настройка предпочтительна, если пользователи уверены, что их приложения корректно обрабатывают сигналы остановки.
- **t** = 0: посылка команды **kill -9** для немедленного завершения.
- **t** > 0: ожидание в течение заданного периода и посылка команды **kill -9** в контейнер, если контейнер не останавливается в течение данного периода.

Поэтому, если параметру **t** задано значение меньше **0** (например, t = -1), убедитесь, что приложение контейнера корректно обрабатывает сигнал SIGTERM. Если контейнер игнорирует этот сигнал, он будет приостановлен при выполнении команды **docker stop**.

### Ручная операция удаления контейнеров, находящихся в состоянии Dead, в связи с занятием соответствующей файловой системы

Удаляя контейнер, Docker останавливает соответствующие процессы контейнера, меняет статус контейнера на Dead, а затем удаляет корневую файловую систему контейнера. Если файловая система или devicemapper заняты, последний шаг, связанный с удалением корневой файловой системы, не выполняется. Выполните команду **docker ps -a.** Результат выполнения команды показывает, что контейнер находится в состоянии Dead. Контейнеры в состоянии Dead нельзя повторно запустить. Дождитесь освобождения файловой системы и повторно запустите команду **docker rm**, чтобы удалить контейнеры.

### Если в контейнерах с общим пространством имен PID дочерний контейнер находится в состоянии паузы, родительский контейнер прекращает отвечать, и команда запуска Docker не выполняется

Если при использовании параметра **--pid** для создания родительских и дочерних контейнеров, которые совместно используют одно пространство имен PID, не может завершиться какой-либо процесс в дочернем контейнере (например, он находится в состоянии D или паузы) при выполнении команды **docker stop**, команда **docker stop** родительского контейнера ставится в ожидание. Необходимо вручную восстановить процесс, чтобы команда могла корректно выполняться.

В этом случае выполните команду **docker inspect** на контейнере, находящемся в состоянии паузы, чтобы проверить, является ли родительский контейнер, соответствующий **PidMode**, контейнером, который делает запрос на остановку командой **docker stop**. Для требуемого контейнера выполните команду **docker unpause**, чтобы отменить состояние паузы дочернего контейнера. Затем перейдите к следующему шагу.

Как правило, возможная причина заключается в том, что пространство имен PID, соответствующее контейнеру, невозможно аннулировать из-за остаточных процессов. Если проблема сохраняется, получите информацию об остаточных процессах и локализации сбоя, связанного с завершением работы процесса в пространстве имен PID, используя инструменты Linux. После решения проблемы контейнер сможет завершить работу.

- Получите идентификатор пространства имен PID в контейнере.
  
  ```
  docker inspect --format={{.State.Pid}} CONTAINERID | awk '{print  "/proc/"$1"/ns/pid"}' |xargs readlink
  ```

- Получите информацию о потоках в пространстве имен.
  
  ```
   ls -l /proc/*/task/*/ns/pid |grep -F PIDNAMESPACE_ID |awk '{print $9}' |awk -F  \/ '{print $5}'
  ```

## Запрос информации о контейнере

Статус контейнера нельзя установить на основе возврата успешного или неуспешного результата выполнения команды **docker**. Для просмотра статуса контейнера рекомендуется использовать следующую команду:

```
docker inspect <NAME|ID>
```

## Операции изменения

### Меры предосторожности при запуске нескольких процессов в контейнере с использованием **docker exec**

Если первая выполненная в контейнере команда **docker exec** является командой **bash**, убедитесь, что все процессы, запущенные **exec**, остановятся перед выполнением команды **exit**. В противном случае устройство может прекратить отвечать при выполнении команды **exit**. Чтобы убедиться, что процесс, запущенный **exec**, продолжает работать в фоновом режиме при выполнении команды **exit**, добавьте **nohup** при запуске процесса.

### Конфликт при использовании команд docker rename и docker stats _container\_name_

Если после выполнения команды **docker stats** *container\_name* для мониторинга контейнера в реальном времени данный контейнер будет переименован командой **docker rename**, имя, отображаемое после выполнения **docker rename**, будет исходным именем, а не переименованным.

### Сбой выполнения операции **docker rename** на контейнере, находящемся в состоянии перезапуска

Если операция переименования выполняется на контейнере, находящемся в состоянии перезапуска, Docker соответствующим образом изменяет конфигурацию сети контейнера. Контейнер, находящийся в состоянии перезапуска, нельзя запустить, и сеть не существует. В результате операция переименования передает ошибку, указывающую на отсутствие песочницы (sandbox). Рекомендуется переименовывать только те контейнеры, которые не находятся в данный момент в состоянии перезапуска.

### docker cp

1. При запуске команды **docker cp** для копирования файлов в контейнер все операции на контейнере будут выполнены только после завершения выполнения команды **docker cp.**
2. Когда контейнер работает под учетной записью пользователя, не имеющего разрешения **root**, выполните команду **docker cp** для копирования файла без разрешения **root** с хоста в контейнер, разрешение на данный файл в контейнере изменится на **root**. В отличие от команды **cp** команда **docker cp** меняет UID и GID файлов, скопированных в контейнер, на статус **root**.

### docker login

После выполнения команды **docker login** данные **user/passwd**, зашифрованные алгоритмом AES (256-битовым), сохраняются в файле **/root/.docker/config.json**. Одновременно генерируется _root_**.docker/aeskey** (разрешение 0600) для дешифрования **usrer/passwd** в файле **/root/.docker/config.json**. В настоящее время ключ AES не обновляется самостоятельно. Для обновления необходимо вручную удалить ключ AES. После обновления ключа AES необходимо вновь войти в демон Docker, чтобы применить его независимо от того, перезапущен демон Docker или нет. Пример:

```
root@hello:~/workspace/dockerfile# docker login 
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. 
Username: example Password: 
Login Succeeded 
root@hello:~/workspace/dockerfile# docker push example/empty 
The push refers to a repository [docker.io/example/empty] 
547b6288eb33: Layer already exists 
latest: digest: sha256:99d4fb4ce6c6f850f3b39f54f8eca0bbd9e92bd326761a61f106a10454b8900b size: 524 
root@hello:~/workspace/dockerfile# rm /root/.docker/aeskey 
root@hello:~/workspace/dockerfile# docker push example/empty 
WARNING: Error loading config file:/root/.docker/config.json - illegal base64 data at input byte 0 
The push refers to a repository [docker.io/example/empty] 
547b6288eb33: Layer already exists 
errors: 
denied: requested access to the resource is denied 
unauthorized: authentication required 
root@hello:~/workspace/dockerfile# docker login 
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. 
Username: example 
Password: 
Login Succeeded 
root@hello:~/workspace/dockerfile# docker push example/empty 
The push refers to a repository [docker.io/example/empty] 
547b6288eb33: Layer already exists 
latest: digest: sha256:99d4fb4ce6c6f850f3b39f54f8eca0bbd9e92bd326761a61f106a10454b8900b size: 524
```