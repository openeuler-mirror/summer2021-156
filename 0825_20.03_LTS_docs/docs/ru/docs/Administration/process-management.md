# Управление процессами

Операционная система управляет множеством запросов пользователей и задач. В большинстве случаев операционная система работает только с одним процессором и одной главной памятью, но может иметь несколько дисков уровня 2 и устройства ввода-вывода. Поэтому пользователи используют ресурсы совместно, но процесс этот для них незаметен, то есть каждый пользователь считает, что занимает ресурсы только он один. Операционная система помещает пользовательские задачи, свои собственные задачи, задачи отправки и получения электронной почты, задачи печати и другие ожидаемые задачи в очередь и планирует их график выполнения в соответствии с заданными правилами. В этом разделе описан подход, используя который операционная система управляет процессами.

\[\[toc]]

## Просмотр информации о процессах

Многозадачной системе Linux необходимо получать информацию о процессах во время управления ими. Чтобы управлять процессами, пользователю необходимо сначала узнать их количество и статусы. Для просмотра информации о процессах доступны несколько команд.

### Команда **who**

Команда **who** отображает информацию пользователя системы. Например, перед запуском команды **talk** для установления мгновенного соединения с другим пользователем необходимо выполнить команду **who**, чтобы убедиться, что целевой пользователь находится в режиме онлайн. Еще один пример: системный администратор выполняет команду **who**, чтобы узнать о действии каждого вошедшего пользователя в текущий момент времени. Команда **who** популярна в системном администрировании за счет простоты использования и передачи в ответ на запрос полного набора точных данных о пользователе.

Далее приводится пример результата выполнения команды **who** с выводом информации о пользователях системы и их статусах. Примеры использования команды **who**:

```
$ who
admin     tty1         Jul 28 15:55
admin     pts/0        Aug  5 15:46 (192.168.0.110)
admin     pts/2        Jul 29 19:52 (192.168.0.110)
root     pts/3        Jul 30 12:07 (192.168.0.110)
root     pts/4        Jul 31 10:29 (192.168.0.144)
root     pts/5        Jul 31 14:52 (192.168.0.11)
root     pts/6        Aug  6 10:12 (192.168.0.234)
root     pts/8        Aug  6 11:34 (192.168.0.234)
```

### Команда **ps**

Команда **ps** — это базовая, но в то же время очень информативная команда, выводящая сведения о процессе. Результат выполнения команды **ps** содержит информацию о конкретных запущенных процессах, о завершенных процессах, о процессах, которым требуются дополнительные ресурсы, и о процессах, завершивших выполнение, но оставшихся в списке процессов операционной системы для считывания кода завершения родительским процессом (процесс-зомби).

Обычный сценарий использования команды **ps** — мониторинг фоновых процессов, которые не взаимодействуют с экраном, клавиатурой и другими устройствами ввода-вывода. В [Табл. 1](#en-us_topic_0151921029_t34619d964a3d41ad8694189ec383359c) приведены общие параметры команды **ps**

**Табл 1** Общие параметры команды **ps**

| Параметр | Описание                                                     |
| -------- | ------------------------------------------------------------ |
| -e       | Отображение всех процессов.                                  |
| -f       | Вывод результата выполнения команды в полном формате.        |
| -h       | Скрытие заголовков столбцов в списке данных процесса.        |
| -l       | Вывод результата выполнения команды в длинном формате.       |
| -w       | Вывод результата выполнения команды в широком формате.       |
| -a       | Вывод списка всех процессов какого-либо терминала, включая процессы других пользователей. |
| -r       | Вывод списка только работающих процессов.                    |
| -x       | Вывод списка всех процессов без указания терминалов.         |
В следующем примере команда выводит список всех процессов терминала:

```
$ ps -a
  PID TTY          TIME CMD
12175 pts/6    00:00:00 bash
24526 pts/0    00:00:00 vsftpd
29478 pts/5    00:00:00 ps
32461 pts/0    1-01:58:33 sh
```

### Команда **top**

Список текущих процессов выводят обе команды — **top** и **ps**, но команда **top** позволяет повторно обновить отображаемый список процессов путем нажатия кнопки. Если команда **top** выполняется в приоритетном режиме (foreground), она занимает ресурсы только в этом режиме до окончательного завершения. Команда **top** дает представление о состоянии системного процессора в реальном времени. Список задач процессора можно сортировать по степени загрузки процессора, степени загрузки памяти или времени выполнения задач. Расширенная настройка отображаемой информации, например выбор столбцов или метода сортировки, достигается с помощью интерактивных команд или файла индивидуальной настройки.

На [Рис. 1](#en-us_topic_0151921029_f289234fcdbac453796200d80e9889cd1) приведен пример результата выполнения команды **top**.

**Рис. 1** Пример результата выполнения команды  
![](./figures/example-command-output.png "example-command-output")

### Команда **kill**

Команда **kill** используется для завершения процесса независимо от того, в каком режиме работает процесс — приоритетном или фоновом. Команда отличается от операции, выполняемой комбинацией клавиш **Ctrl+c**, которая завершает только приоритетные процессы. Причиной завершения фонового процесса может быть высокая загруженность ресурсов процессора или взаимоблокировка (deadlock).

Команда **kill** отправляет сигнал для завершения текущих процессов. По умолчанию используется сигнал TERM, который завершает все процессы, не способные его перехватить. Чтобы завершить процесс, способный перехватить сигнал TERM, используется сигнал KILL (идентификатор сигнала: 9).

Два типа синтаксиса команды **kill**:

```
kill [-s signal | -p] [-a] PID…
kill -l [signal]
```

Идентификатор процесса извлекается из команды **ps**. Параметр **-s** означает сигнал, отправленный в указанную программу. Подробную информацию о сигнале можно посмотреть, выполнив команду **kill** **-l**. Параметр **-p** — это указанные идентификаторы процесса.

Например, для завершения процесса с идентификатором 1409 выполните следующую команду как пользователь **root**:

```
# kill -9 1409
```

Пример вывода команды **kill** с параметром **-l**:

```
$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

## Планирование процесса

Операции по техобслуживанию, занимающие много времени и ресурсов, часто выполняются в ночные часы. С помощью планирования процессы запускаются в назначенное время, не требуя присутствия пользователя всю ночь. В этом разделе описаны команды планирования процессов.

### Запуск процессов в запланированное время командой **at**

#### Функции

Команда **at** используется для запуска группы процессов (серии команд) в назначенное время или назначенные время и дату.

Синтаксис команды **at**:

```
at [-V] [-q queue] [-f filename] [-mldbv] time
at -c job [job...]
```

#### Формат времени

Планируемое время можно указать в любом из следующих форматов:

- hh:mm today: если hh:mm (чч:мм) раньше текущего времени, выбранные команды будут выполняться в чч:мм на следующий день.
- midnight (полночь), noon (полдень), teatime (полдник) (обычно в 16:00) и т.п.
- Время в 12-часовом формате, за которым следует am (до полудня) или pm (после полудня)
- Время + дата (день месяца, мм/дд/гг или дд.мм.гг). Запланированная дата должна следовать за запланированным временем.

Запланированное время также может быть относительным, что подходит для планирования команд, которые должны быть выполнены в ближайшее время. Например, now+_N_ minutes, hours, days, weeks. *N* — время, которое может быть выражено в днях или часах. Запланированное время можно обозначить такими словами, как today (сегодня), tomorrow (завтра) и т.п. Далее приведены примеры запланированного времени.

Допустим, текущее время — 12:30 7 июня 2019 г., и требуется запустить команду в 16:30 вечера. Запланированное время в команде **at** можно обозначить любым из следующих способов:

```
 at 4:30pm
 at 16:30
 at 16:30 today
 at now+4 hours
 at now+ 240 minutes
 at 16:30 7.6.19
 at 16:30 6/7/19
 at 16:30 Jun 7
```

Хотя указать время можно любым из способов в вышеприведенных примерах в соответствии с предпочтениями, рекомендуется выбрать абсолютное время в 24-часовом формате, например: 16:30 6/7/19.

#### Полномочия

С помощью команды **at** можно запланировать выполнение только тех операций, которые входят в стандартный ввод или включены в файл опцией -f. Если для переключения операционной системы с пользователя A на пользователя B выполняется команда **su**, а затем выполняется команда **at** в строке приглашения оболочки пользователя B, результат выполнения команды **at** отправляется пользователю B, в то время как сообщение по электронной почте (если таковое имеется) отправляется пользователю А.

Например, чтобы запустить команду **slocate** **-u** в 10 утра 8 июня 2019 г., выполните следующие шаги как пользователь **root**:

```
# at  10:00  6/8/19
at> slocate -u
at>
[1]+   Stopped    at  10:00  6/8/19
```

При появлении символа приглашения at> введите **slocate -u** и нажмите Enter. Повторите подшаг 2, чтобы добавить другие команды, которые должны быть запущены в 10 утра 8 июня 2019 года. Далее нажмите комбинацию клавиш Ctrl+d, чтобы выйти из процесса команды **at**.

Администратор не имеет ограничений в правах на выполнение команды **at**. Для остальных пользователей полномочия на выполнение команды **at** определяются в файлах /etc/at.allow и /etc/at.deny.

### Периодический запуск команд на выполнение с помощью службы cron

Команда **at** может запускать команды на выполнение в запланированное время, но только однократно. То есть после планирования команды на выполнение система выполнит эту задачу в указанное время. Если необходимо повторно выполнить такую команды, с этой задачей хорошо справляется служба cron.

#### Служба cron

Служба **cron** выполняет поиск в каталоге **/var/spool/cron** файлов **crontab,** приведенных по имени пользователя в файле /etc/passwd, и загружает результаты поиска в память для выполнения команд, содержащихся в файлах **crontab**. Каждый пользователь имеет файл **crontab**, имя которого совпадает с именем пользователя. Например, файлом **crontab** пользователя **userexample** является **/var/spool/cron/userexample**.

Служба **cron** также каждую минуту считывает конфигурационный файл cron **/etc/crontab**, который можно редактировать в различных форматах. Не найдя файлы crontab, служба **cron** входит в спящий режим и освобождает системные ресурсы. Минуту спустя служба **cron** переходит в активное состояние и повторяет поиск и выполнение команд. Таким образом, фоновый процесс, занимая небольшой объем ресурсов, активизируется каждую минуту, чтобы проверить наличие команд, которые необходимо выполнить.

Результаты выполнения команды затем передаются по электронной почте пользователям, указанным с помощью переменной среды MAILTO в файле /etc/crontab. Запущенная один раз служба **cron** не требует дальнейшего ручного вмешательства пользователя, за исключением случаев, когда необходимо заменить периодически выполняемые команды другими командами.

#### Команда **crontab**

Данная команда используется для установки, редактирования, удаления, составления списка и выполнения других операций в файлах crontab. Каждый пользователь, имея свои собственные файлы crontab, может добавлять в них команды, требующие выполнения.

Ниже приведены общие параметры команды crontab:

- crontab -u //Установка службы **cron** пользователя. Этот параметр необходим только в том случае, если команда **crontab** запускается пользователем **root**.
- crontab -l //Компоновка сведений о службе **cron** пользователя.
- crontab -r //Удаление службы **cron** пользователя.
- crontab -e //Редактирование службы **cron** пользователя.

В приведенном примере команда выводит перечень настроек службы **cron** пользователя **root**:

```
# crontab -u root -l
```

#### Файлы crontab

В файлах crontab перечисляются команды, которые необходимо выполнить, и время выполнения. Каждая строка в таких файлах содержит шесть полей. Первые пять полей отведены под время, в которое указанная команда будет выполнена, а последнее поле — под команду, которую необходимо выполнить. Поля отделяются пробелами или символами табуляции. Формат команды выглядит следующим образом:

```
minute hour day-of-month month-of-year day-of-week commands
```

Описание полей:

**Табл. 2** Описание параметров

| Параметр      | Описание                                                     |
| ------------- | ------------------------------------------------------------ |
| minute        | Минута часа, в который будут выполняться команды. Диапазон значений: 0–59. |
| hour          | Час дня, в который будут выполняться периодически запускаемые команды. Диапазон значений: 0–23. |
| day-of-month  | День месяца, в который будут выполняться периодически запускаемые команды. Диапазон значений: 1–31. |
| month-of-year | Месяц года, в который будут выполняться периодически запускаемые команды. Диапазон значений: 1–12. |
| day-of-week   | День недели, в который будут выполняться периодически запускаемые команды. Диапазон значений: 0–6. |
| commands      | Периодически запускаемые команды.                            |
Поля обязательно должны быть заполнены. Помимо цифр допускаются следующие специальные символы: 

- Звездочка (\*): знак подстановки. 
- Косая черта (/): за этим символом следует число N, что означает, что команды будут выполняться с регулярным интервалом N. 
- Дефис (-): используется для обозначения диапазонов. 
- Запятая (,): используется для разделения дискретных чисел. 

Необходимо указать полный путь к командам.

Например, чтобы операционная система добавляла «sleepy» в файл /tmp/test.txt каждые два часа с 18:00 до 22:00, добавьте следующую строку в файл crontab:

```
* 18-22/2 * * * echo "sleepy" >> /tmp/test.txt
```

Каждый раз, когда изменяются настройки службы cron пользователя, данная служба создает в каталоге /var/spool/cron файл cronab с именем пользователя. Файл crontab можно редактировать только с помощью команды crontab -e. Альтернативный способ: пользователь может создать файл и выполнить команду **crontab** *имя файла* для импорта настроек службы cron в этот новый файл.

В следующем примере команды создается файл crontab для пользователя userexample. Процедура выглядит следующим образом:

1. Создайте файл с помощью любого текстового редактора. Добавьте в созданный файл команды, которые необходимо периодически выполнять, и интервал выполнения команд. В этом примере создан новый файл **~/userexample.cron**.

2. Установите новый файл в качестве файла crontab пользователя userexample, выполнив следующую команду как пользователь **root**:
   
   ```
   # crontab -u userexample ~/userexample.cron
   ```

После установки нового файла в каталоге **/var/spool/cron** появится файл userexample. Этот файл является требуемым файлом crontab.

> ![](./public_sys-resources/icon-note.gif) **ПРИМЕЧАНИЕ**:  
Не перезапускайте службу **cron** после изменения файла **crontab**, поскольку запущенная служба считывает файл **crontab** каждую минуту, проверяя наличие команд, которые необходимо периодически выполнять.

#### Файл /etc/crontab

Служба **cron** считывает все файлы в каталоге **/var/spool/cron**, и файл **crontab** в каталоге **/etc/cronab** каждую минуту. Поэтому можно использовать службу **cron**, настроив файл **crontab**. Файл **crontab** содержит пользовательские команды, а файл **/etc/crontab** — общесистемные команды. Пример файла /etc/crontab:

```
SHELL=/bin/sh
PATH=/usr/bin:/usr/sbin:/sbin:/bin:/usr/lib/news/bin
MAILTO=root //If an error occurs or data is output, the data is sent to the account by email.
HOME=/
#  run-parts
01 * * * * root run-parts /etc/cron.hourly //Run scripts in the /etc/cron.hourly directory once an hour.
02 4 * * *   root run-parts /etc/cron.daily    //Run scripts in the /etc/cron.daily directory once a day.
22 4 * * 0  root run-parts /etc/cron.weekly     //Run scripts in the /etc/cron.weekly directory once a week.
42 4 1  * *  root run-parts /etc/cron.monthly     //Run scripts in the /etc/cron.monthly directory once a month.
```

> ![](./public_sys-resources/icon-note.gif) **ПРИМЕЧАНИЕ**:  
Если параметр **run-parts** удаляется, вместо имени каталога выполняется имя скрипта.

## Приостановка и возобновление процесса

Процесс можно приостановить или возобновить с помощью функции управления заданиями. После возобновления процесс продолжит работу с момента приостановки. Чтобы приостановить приоритетный процесс, нажмите Ctrl+Z. После этого приостановится выполнение команды **cat** вместе с приоритетным процессом, который требуется приостановить. Вместо этого можно использовать команду **jobs** для вывода списка заданий оболочки, включая имена, идентификаторы и статусы заданий.

Чтобы возобновить процесс в приоритетном режиме, выполните команду **fg**, для фонового режима — команду **bg**. Процесс запустится с того момента, в котором он был ранее приостановлен.