# Применение компиляторов JDK

\[\[toc]]

## Обзор

Комплект для разработки приложений на языке Java (Java Development Kit; JDK) представляет собой программный пакет, который содержит исполнительную среду Java Runtime Environment (JRE) и инструменты компиляции и запуска. На основе комплекта OpenJDK сообщество openEuler оптимизирует GC, повышает стабильность параллельных операций и повышает безопасность, увеличивая производительность и устойчивость работы Java-приложений на архитектуре ARM.

## Основные сведения

### Тип и инструмент файла

Тип каждого указанного входного файла определяет инструмент, который будет использован для обработки. Стандартные типы файлов и инструменты приведены в [Табл. 1](#table634145764320) и [Табл. 2](#table103504146433).

**Табл. 1** Стандартные типы файлов JDK

| **Расширение (суффикс)** | **Описание**                                                 |
| ------------------------ | ------------------------------------------------------------ |
| .java                    | Файл с исходным кодом на языке программирования Java.        |
| .class                   | Файл с байт-кодом на языке программирования Java, который является промежуточным кодом, не имеющим отношение к какой-либо конкретной машине или среде ОС. Это двоичный файл, который является файлом целевого кода, генерируемым после того, как компилятор Java скомпилирует файл с исходным кодом Java. |
| .jar                     | Пакет JAR с файлами Java.                                    |

**Табл. 2** Стандартные инструменты JDK

| **Имя** | **Описание**                                                 |
| ------- | ------------------------------------------------------------ |
| java    | Инструмент, используемый для запуска файлов .class с байт-кодом или файлов .jar. |
| javac   | Компиляция файлов с исходным кодом Java в файлы .class с байт-кодом. |
| jar     | Создание и управление файлами JAR.                           |

### Процесс создания программы Java

Для создания программы на основе файлов с исходным кодом Java и запуска программы на языке Java необходимо скомпилировать и исполнить файлы.

1. Компиляция: компиляция файлов с исходным кодом Java (файлы .java) в файлы с байт-кодом .class осуществляется с помощью компилятора Java (javac).
2. Исполнение: файлы с байт-кодом исполняются на виртуальной машине Java (JVM).

### Общие параметры JDK

#### Параметры компилятора javac

Формат команды для компиляции javac выглядит следующим образом:  **javac**  \[_options_] \[_sourcefiles_] \[_classes_] \[@_argfiles_]

Параметры:

*options*: выбираемые параметры команды.

*sourcefiles*: один или несколько исходных файлов, подлежащих компиляции.

*classes*: один или несколько классов, которые должны обрабатываться как комментарии.

@_argfiles_: один или несколько файлов, в которых перечисляются опции и исходные файлы. Опция **-J** не допустима в этих файлах.

Javac представляет собой компилятор языка Java. В компиляторе предусмотрен ряд параметров, указываемых в поле *options*, но большинство из них используются редко. В [Табл. 3](#table1342946175212) приведено описание часто используемых параметров.

**Табл 3** Общие параметры компилятора javac

| Значение *options*               | **Описание**                                                 | **Пример**                                                   |
| -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| -d *path*                        | Путь для хранения сгенерированных файлов .class. По умолчанию файлы .class, сгенерированные после компиляции, находятся в каталоге с тем же путем, что и исходный файл. Параметр **-d** используется для экспорта файлов .class по указанному пути. | #В данном примере параметр **-d** используется для экспорта всех файлов .class в каталог **bin**.  javac /src/*.java -d /bin |
| -s *path*                        | Путь для хранения сгенерированных файлов с исходным кодом.   | -                                                            |
| -cp *path* или -classpath *path* | С данным параметром выполняется поиск файлов .class, необходимых для компиляции, и задается место хранения файлов .class. | #В демо-режиме осуществляется вызов метода getLine() в классе GetStringDemo. Файл .class, скомпилированный классом GetStringDemo, хранится в каталоге **bin**.  javac -cp bin Demo.java -d bin |
| -verbose                         | Данный параметр выводит информацию об операциях, выполняемых компилятором, например информацию о загруженных классах и информацию о скомпилированном файле с исходным кодом. | #В приведенном примере отображается информация об операциях, выполняемых компилятором.  javac -verbose -cp bin Demo.java |
| -source *sourceversion*          | Данный параметр указывает место хранения входящих файлов с исходным кодом, поиск которых будет осуществляться. | -                                                            |
| -sourcepath *path*               | Поиск файлов с исходным кодом (файлов Java), необходимых для компиляции, и задание места хранения файлов с исходным кодом, поиск которых будет осуществляться, например JAR, ZIP или другие каталоги, содержащие файлы Java. | -                                                            |
| -target *targetversion*          | Генерирование файлов .class для определенной версии JVM. Значением может быть 1.1, 1.2, 1.3, 1.4, 1.5 (или 5), 1.6 (или 6), 1.7 (или 7) или 1.8 (или 8). Значение по умолчанию *targetversion* связано с версией исходного кода *sourceversion* в параметре **-source**. Варианты версий *sourceversion*: <br /> ·      1.2 соответствует целевой версии 1.4  <br />·      1.3 соответствует целевой версии 1.4  <br />·      1.5, 1.6, 1.7 и отсутствие указанной версии соответствуют целевой версии 1.8 <br /> ·      В отношении остальных значений версии *targetversion* и *sourceversion* совпадают. | -                                                            |

#### Параметры команды исполнения Java

Формат команды исполнения Java выглядит следующим образом:

Исполнение файла .class:  **java**  \[_options_]  _classesname_  \[args]

Исполнение файла Java:  **java**  \[_options_] -jar  _filename_  \[args]

Параметры:

*options*: параметры команды, разделенные пробелами.

*classname*: имя исполняемого файла .class.

*filename*: имя исполняемого файла .jar.

*args*: параметры, передаваемые функции main(). Параметры разделяются пробелами.

Java является инструментом для запуска приложений Java. В компиляторе предусмотрен ряд параметров, указываемых в поле *options*, но большинство из них используются редко. В [Табл. 4](#table371918587238) приведено описание часто используемых параметров.

**Табл 4** Общие параметры команд исполнения файлов на языке Java

| Значение  *options*              | Описание                                                     | **Пример**                                                   |
| -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| -cp *path* или -classpath *path* | Параметр задает местоположение запускаемого файла и путь к классу, который необходимо использовать, включая каталоги файлов .jar, .zip и .class. При указании нескольких путей их необходимо перечислить, разделив двоеточием (:). | -                                                            |
| -verbose                         | Данный параметр выводит информацию об операциях, выполняемых компилятором, например информацию о загруженных классах и информацию о скомпилированном файле с исходным кодом. | #В приведенном примере отображается информация об операциях, выполняемых компилятором.  java  -verbose -cp bin Demo.java |

#### Параметры JAR

Формат команды JAR выглядит следующим образом:  **jar**  {c \| t \| x \| u}\[vfm0M] \[_jarfile_] \[_manifest_] \[-C  _dir_]  _file_...

В [Табл. 5](#table3691718114817) приведены параметры команды **jar**.

**Табл. 5** Описание параметров JAR

| **Параметр** | Описание                                                     | Пример                                                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| c            | Создание пакета JAR.                                         | #В приведенном примере файлы hello.class в текущем каталоге сжимаются в пакет Hello.jar. Процесс сжатия не отображается. Если файлы Hello.jar не существуют, создайте их. В противном случае очистите каталог.  jar  cf Hello.jar hello.class |
| t            | Вывод содержимого пакета JAR.                                | #В приведенном примере перечисляются файлы, включенные в пакет Hello.jar.  jar tf  Hello.jar |
| x            | Распаковка пакета JAR.                                       | #В приведенном примере содержимое Hello.jar распаковывается в текущий каталог.  Информация не отображается.  jar xf  Hello.jar |
| u            | Данный параметр обновляет существующий пакет JAR, например, добавляет в него файлы. | -                                                            |
| v            | Генерация подробного отчета и его печать в стандартный вывод. | #В приведенном примере файлы hello.class в текущем каталоге сжимаются в пакет Hello.jar, и при этом, отображается процесс сжатия. Если файлы Hello.jar не существуют, создайте их. В противном случае очистите каталог.  jar  cvf Hello.jar hello.class |
| f            | Параметр задает имя пакета JAR. Параметр обязательный.       | -                                                            |
| m            | Параметр файл manifest, который необходимо включить в содержимое. | -                                                            |
| 0            | Если этот параметр не установлен, сгенерированный пакет JAR размером будет больше пакета, сгенерированного с установленным параметром, но обрабатываться будет быстрее. | -                                                            |
| M            | Если файл manifest не генерируется для всех элементов, этот параметр игнорируется. | #В приведенном примере файлы hello.class в текущем каталоге сжимаются в пакет Hello.jar, и при этом, отображается процесс сжатия. Если файлы Hello.jar не существуют, создайте их. В противном случае очистите каталог. Однако файл manifest не генерируется при создании пакета Hello.jar.  jar  cvfM Hello.jar hello.class |
| *jarfile*    | Пакет JAR, являющийся вспомогательным параметром параметра **f**. | -                                                            |
| *manifest*   | Файл manifest в формате .mf, являющийся вспомогательным параметром параметра **m**. | -                                                            |
| -C *dir*     | Данный параметр запускает команду **jar** в указанном каталоге *dir*. Эту команду можно использовать только с параметрами **c** и **t**. | -                                                            |
| *file*       | Параметр задает файл или путь. Все файлы, находящиеся в таком файле или по такому пути (включая те, которые находятся по рекурсивном пути), сжимаются в пакет JAR, или же пакет JAR распаковывается в каталог по указанному пути. | #В приведенном примере все файлы .class в текущем каталоге сжимаются в пакет Hello.jar, и при этом, отображается процесс сжатия. Если файлы Hello.jar не существуют, создайте их. В противном случае очистите каталог.  jar  cvf Hello.jar *.class |

## Библиотека классов

Библиотека классов Java реализуется как пакет, который представляет собой набор классов и интерфейсов. Компилятор Java генерирует файл с байт-кодом для каждого класса, и имя файла совпадает с именем класса. Поэтому между классами с одинаковым именем могут возникать конфликты. На языке Java группа классов и интерфейсов инкапсулируется в один пакет. Этот пакет может эффективно управлять пространством имен классов. Классы в разных пакетах не конфликтуют, даже если они имеют одинаковое имя. Это решает проблему конфликтов между классами с одинаковым именем и облегчает управление большим количеством классов и интерфейсов. Данный подход также гарантирует безопасность классов и интерфейсов.

Разработчики могут не только использовать пакеты, предоставляемые Java, но и компоновать собственные пакеты. Пакет, собранный из скомпилированных классов и интерфейсов, можно использовать в дальнейшем.

Перед использованием индивидуально собранного пакета необходимо его задекларировать.

### Декларация пакета

Формат декларации пакета: pkg1\[.pkg2\[.pkg3...]].

Чтобы задекларировать пакет, необходимо создать каталог. Имя подкаталога должно быть таким же, как и имя пакета. Затем пакет декларируется в начале файла .class, который должен быть помещен в пакет, указывая на то, что данному пакету принадлежат все классы файла. Точка (.) в декларации пакета означает иерархию каталогов. Если файл с исходной программой не содержит оператор пакета, данный пакет указывается как анонимный пакет. Анонимный пакет не имеет пути. Как правило, Java сохраняет классы в исходном файле в текущем рабочем каталоге (то есть каталоге, в котором хранятся исходные файлы Java).

Оператор декларации пакета необходимо добавить в начало файла исходного кода программы, и перед ним не ставятся комментарии или пробелы. Если в разных исходных кодах программы используется один оператор декларации пакета, можно включить классы, содержащиеся в разных файлах с исходными кодами программы, в один пакет.

### Ссылка на пакет

Можно использовать общие классы, доступные в пакете Java, или классы в индивидуально собранном пакете.

- Добавьте имя пакета перед именем класса, на который необходима ссылка.
  
  Например, name.A obj=new name.A ()
  
  **name** — имя пакета, **A** — имя класса, а **obj** — объект. Эта строка указывает, что класс **A** в пакете **name** используется для определения объекта **obj** в программе.
  
  Пример. В данном примере создается тестовый объект класса **Test** в пакете **example**.
  
  ```
  example.Test test = new example.Test();
  ```

- Для импорта классов в пакет необходимо вставить **import** в начале файла.
  
  Формат оператора **import**: pkg1\[.pkg2\[.pkg3...]].(classname \| \*).
  
  **pkg1\[.pkg2\[.pkg3...]]** — уровень пакета, а **classname** — имя класса, который необходимо импортировать. Если планируется импортировать несколько классов из одного пакета, можно использовать знак подстановки (\*).
  
  Пример. В данном примере импортируется класс **Test** в пакет **example**.
  
  ```
  import example.Test;
  ```
  
  Пример. В данном примере импортируется полный пакет **example**.
  
  ```
  import example.*;
  ```

## Примеры

### Компиляция программы Java без пакета

1. Выполните команду **cd**, чтобы перейти в каталог хранения кода. В примере используется каталог **~/code**. Команда выглядит следующим образом:
   
   ```
   $ cd ~/code 
   ```

2. Скомпилируйте программу Hello World и сохраните ее в виде **HelloWorld.java**. Далее приведен пример с программой Hello World. Команда выглядит следующим образом:
   
   ```
   $ vi HelloWorld.java
   ```
   
   Пример кода:
   
   ```
   public class HelloWorld {     
        public static void main(String[] args) {         
            System.out.println("Hello World");     
         } 
   }
   ```

3. Выполните следующую команду, чтобы скомпилировать код в каталог хранения кода:
   
   ```
   $ javac HelloWorld.java 
   ```
   
   Если ошибок нет, команда выполнена успешно.

4. После завершения компиляции генерируется файл HelloWorld.class. Просмотр результатов осуществляется командой **java**. Пример:
   
   ```
   $ java HelloWorld
   Hello World
   ```

### Компиляция программы Java с пакетом

1. Выполните команду **cd**, чтобы перейти в каталог хранения кода. В примере используется каталог **~/code**. Создайте подкаталоги **~/code/Test/my/example**, **~/code/Hello/world/developers** и **~/code/Hi/openos/openeuler** в каталоге для хранения исходных файлов.
   
   ```
   $ cd ~/code
   $ mkdir -p Test/my/example
   $ mkdir -p Hello/world/developers
   $ mkdir -p Hi/openos/openeuler
   ```

2. Выполните команду **cd**, чтобы перейти в каталог **~/code/Test/my/example** и создать **Test.java**.
   
   ```
   $ cd ~/code/Test/my/example
   $ vi Test.java
   ```
   
   Пример кода Test.java:
   
   ```
   package my.example;
   import world.developers.Hello;
   import openos.openeuler.Hi;
   public class Test {
     public static void main(String[] args) {
      Hello me = new Hello();
      me.hello();
      Hi you = new Hi();
      you.hi();
     }
   }
   ```

3. Выполните команду **cd**, чтобы перейти в каталог **~/code/Hello/world/developers** и создать **Hello.java**.
   
   ```
   $ cd ~/code/Hello/world/developers
   $ vi Hello.java
   ```
   
   Пример кода Hello.java:
   
   ```
   package world.developers;
   public class Hello {
     public void hello(){
      System.out.println("Hello, openEuler.");
     }
   }
   ```

4. Выполните команду **cd**, чтобы перейти в каталог **~/code/Hi/openos/openeuler** и создать **Hi.java**.
   
   ```
   $ cd ~/code/Hi/openos/openeuler
   $ vi Hi.java
   ```
   
   Пример кода Hi.java:
   
   ```
   package openos.openeuler;
   public class Hi {
     public void hi(){
      System.out.println("Hi, the global developers.");
     }
   }
   ```

5. Выполните команду **cd**, чтобы перейти в каталог **~/code** и использовать javac для компиляции исходного файла.
   
   ```
   $ cd ~/code
   $ javac -classpath Hello:Hi Test/my/example/Test.java
   ```
   
   После выполнения команды файлы **Test.class**, **Hello.class** и **Hi.class** генерируются в каталогах **~/code/Test/my/example**, **~/code/Hello/world/developers** и **~/code/Hi/openos/openeuler**.

6. Выполните команду **cd**, чтобы перейти в каталог **~/code** и выполните программу **Test** для использования Java.
   
   ```
   $ cd ~/code
   $ java -classpath Test:Hello:Hi my/example/Test
   ```
   
   Выходные данные команды выглядят следующим образом:
   
   ```
   Hello, openEuler.
   Hi, the global developers.
   ```