# Установка и развертывание

- [Установка и развертывание](#installation-and-deployment-2)
  - [Меры предосторожности](#precautions)
  - [Настройка базовых установочных компонентов](#basic-installation-configuration)
    - [Настройка параметров демона](#daemon-parameter-configuration)
    - [Настройка текущего рабочего каталога демона](#daemon-running-directory-configuration)
    - [Настройка сети демона](#daemon-network-configuration)
    - [Настройка значения umask демона](#daemon-umask-configuration)
    - [Время запуска Daemon](#daemon-start-time)
    - [Компонент Journald](#journald-component)
    - [Компонент Firewalld](#firewalld-component)
    - [Компонент Iptables](#iptables-component)
    - [Компонент Audit](#audit-component)
    - [Функция безопасности seccomp](#security-configuration-seccomp)
    - [Запрет на операции изменения частного каталога демона Docker](#do-not-modify-private-directory-of-docker-daemon)
    - [Меры предосторожности для обычных пользователей в сценарии с развертыванием большого количества контейнеров](#precautions-for-common-users-in-the-scenario-where-a-large-number-of-containers-are-deployed)
  - [Настройка драйвера хранилища](#storage-driver-configuration)
    - [Настройка драйвера хранилища overlay2](#overlay2-storage-driver-configuration)
    - [Настройка драйвера хранилища devicemapper](#devicemapper-storage-driver-configuration-35)
  - [Результат принудительного аннулирования фоновых процессов Docker](#impact-of-forcibly-killing-docker-background-processes)
    - [Вероятность сохранения остаточных ресурсов семафоров](#semaphores-may-be-residual)
    - [Вероятность сохранения остаточных ресурсов[NIC]](#nics-may-be-residual)
    - [Сбой перезапуска контейнера](#failed-to-restart-a-container)
    - [Сбой перезапуска службы ](#failed-to-restart-a-container)[Docker](#failed-to-restart-the-docker-service)
  - [Результат отключения питания системы](#impact-of-system-power-off)

## Меры предосторожности

- RPM-пакет **docker-engine** нельзя устанавливать вместе с RPM-пакетом **containerd**, **runc** или **podman**. Это связано с тем, что RPM-пакет **docker-engine** содержит все компоненты, необходимые для работы Docker, включая бинарные файлы **containerd**, **runc** и **docker**. При этом RPM-пакеты **containerd**, **runc** и **podman** также содержат соответствующие бинарные файлы. Из-за повторной установки могут возникнуть конфликты пакетов программного обеспечения.

## Настройка базовых установочных компонентов

### Настройка параметров демона

Для настройки параметров элементы конфигурации добавляются в файл **/etc/docker/daemon.json**. Командой **dockerd --help** осуществляется просмотр соответствующих элементов конфигурации и методов их использования. Пример настройки:

```
cat /etc/docker/daemon.json 
{        
    "debug": true,        
    "storage-driver": "overlay2",        
    "storage-opts": ["overlay2.override_kernel_check=true"] 
}
```

### Настройка текущего рабочего каталога демона

Повторная настройка рабочих каталогов и файлов (в том числе **--graph** и **--exec-root**) может стать причиной конфликта каталогов или изменения атрибутов файлов, что негативно отразится на использовании приложений.

> ![](./public_sys-resources/icon-notice.gif) **ПРИМЕЧАНИЕ**:  
Поэтому указанные каталоги или файлы должны использоваться только движком Docker, чтобы не допустить изменений атрибутов файлов и проблем с безопасностью, вызванных конфликтами.

- Здесь в качестве примера приведен параметр **--graph**. Если новым корневым каталогом демона является **/new/path/**, в котором уже находится какой-то файл, и имя каталога или имя файла конфликтует с именем, требуемым Docker (например, **containers**, **hooks** и **tmp**), возможно изменение исходного каталога или атрибутов файла, включая владельца и разрешение, со стороны Docker.

> ![](./public_sys-resources/icon-notice.gif) **ПРИМЕЧАНИЕ**:  
В Docker версии 17.05 параметр **--graph** отмечен как **Deprecated** и заменен параметром **--data-root**.

### Настройка сети демона

- Если после настройки сетевого сегмента docker0 bridge с помощью параметра **--bip** в демоне Docker параметр **--bip** будет удален во время следующего перезапуска демона Docker, docker0 bridge примет предыдущее значение **--bip** даже в случае удаления docker0 bridge перед перезапуском. Причина заключается в том, что Docker сохраняет конфигурацию сети и восстанавливает предыдущую конфигурацию по умолчанию во время следующего перезапуска.
- При выполнении команды **docker network create** для параллельного создания сетей можно создать две сети с одним именем. Это возможно, потому что сети Docker отличаются идентификаторами. Имя представляет собой всего лишь псевдоним, который легко идентифицировать, и оно необязательно должно быть уникальным.
- В режиме мостовой сети Docker контейнер Docker устанавливает внешнее соединение через NAT на хосте. Когда демон Docker запускает контейнер Docker, для каждого порта, сопоставленного на хосте, запускается процесс docker-proxy для доступа к прокси-серверу. С целью сокращения ресурсов, потребляемых процессом сопоставления портов docker-proxy, рекомендуется при использовании userland-proxy сопоставлять только необходимые порты.

### Настройка значения umask демона

Значение **umask** по умолчанию для процесса главного контейнера и процесса exec — **0022**. Чтобы соответствовать спецификациям безопасности и предотвратить атаку на контейнеры, после изменения реализации runC значение по умолчанию **umask** изменяется на **0027**. После изменения другие группы не смогут получить доступ к новым файлам или каталогам.

Во время запуска контейнера движком Docker значение по умолчанию **umask** — **0027**. Изменить значение на **0022** можно, выполнив команду **--exec-opt native.umask=normal** во время запуска контейнера.

> ![](./public_sys-resources/icon-notice.gif) **ПРИМЕЧАНИЕ**:  
Если параметр **native.umask** указан в команде **docker create** или **docker run**, то указывается данное значение.

Подробнее см. описание параметров в разделах [4.6.2.4 create](#create.md#EN-US_TOPIC_0184808242) и [4.6.2.16 run](#container-management-40.md#EN-US_TOPIC_0184808238).

### Время запуска демона

Служба Docker управляется посредством systemd, что ограничивает время запуска каждой службы. Если служба Docker не запускается в указанное время, причины могут быть следующие:

- При первом запуске с помощью devicemapper демон Docker должен выполнить операцию инициализации на устройстве. Эта операция, однако, приведет к большому количеству операций ввода-вывода на диске. При низкой производительности диска или наличии множественных конфликтов в системе ввода-вывода может произойти таймаут запуска демона Docker. devicemapper необходимо инициализировать только один раз и во время последующего запуска демона Docker инициализация не требуется.
- В случае высокой загрузки текущих системных ресурсов отклик в системе будет медленный, все операции в системе замедлятся, и время ожидания запуска службы Docker может истечь.
- Во время перезапуска демон просматривает и считывает конфигурационные файлы, настройки слоя init и слоя записи каждого контейнера в рабочем каталоге Docker. Если в текущей системе слишком много контейнеров (включая созданные и завершившие работу контейнеры) и производительность чтения и записи диска ограничена, время ожидания запуска службы Docker может истечь в связи с длительным просмотром демоном настроек.

  В случае таймаута запуска службы рекомендуется устранить ошибку следующим образом:

- Убедитесь, что слой оркестрации контейнеров периодически удаляет ненужные контейнеры, особенно завершившие работу контейнеры.
- Ориентируясь на требования к производительности решения, скорректируйте период сброса для слоя оркестрации и время запуска службы Docker.

### Компонент Journald

После перезапуска systemd-journald необходимо перезапустить демон Docker. Journald получает журналы демона Docker через системный вызов pipe. Если служба journald перезапускается, pipe отключается. Операция записи журналов Docker инициирует сигнал SIGPIPE, который вызывает сбой демона Docker. Игнорирование данного сигнала может привести к тому, что последующие журналы демона Docker не будут записаны. Поэтому рекомендуется перезапустить демон Docker после перезапуска службы journald или перехода ее в некорректное состояние. Это обеспечит корректность записи журналов Docker и предотвратит появления некорректных состояний в связи со сбоем работы демона.

### Компонент Firewalld

После перезапуска или запуска компонента firewalld необходимо перезапустить службу Docker.

- При запуске службы firewalld удаляются правила iptables текущей системы. Поэтому если служба firewalld перезапускается во время запуска демона Docker, возможно, что она не введет правила iptables, что приведет к сбою запуска служба Docker.
- Если служба firewalld перезапускается после запуска службы Docker или изменяется статус службы firewalld (приостановка или возобновление работы службы), правила iptables службы Docker удаляются. Это приведет к невозможности создания контейнера с соответствующими портами.

### Компонент Iptables

Добавление в Docker параметра **--icc=false** может привести к ограничению связи между контейнерами. Однако если в ОС имеются определенные правила, связь между контейнерами не ограничивается. Пример:

```
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) 
... 
0     0 ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0 
... 
0     0 DROP       all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0
...
```

В команде **Chain FORWARD** в **DROP** добавлено правило ACCEPT icmp. В результате, после добавления параметра **--icc=false** контейнеры могут проверить связь друг с другом командой ping, но при использовании UDP или TCP противоположный узел будет недоступен.

Поэтому прежде чем добавить параметр **--icc=false** при использовании движка Docker в контейнере, рекомендуется сначала выполнить сброс правил iptables на хосте.

### Компонент Audit

Для Docker доступна настройка компонента audit. Однако этот компонент не обязателен. Пример:

```
-w /var/lib/docker -k docker 
-w /etc/docker -k docker 
-w /usr/lib/systemd/system/docker.service -k docker 
-w /usr/lib/systemd/system/docker.socket -k docker 
-w /etc/sysconfig/docker -k docker 
-w /usr/bin/docker-containerd -k docker 
-w /usr/bin/docker-runc -k docker 
-w /etc/docker/daemon.json -k docker
```

Настройка компонента audit для Docker приносит определенные преимущества в плане аудита, хотя существенно не влияет на защиту от атак. Кроме того, конфигурация данного компонента вызывает серьезные проблемы с эффективностью, например, может нарушить плавный отклик системы. Поэтому следует осторожно использовать данный компонент в рабочей среде.

Далее в качестве примера для описания настройки компонента audit для Docker используется **-w /var/lib/docker -k docker**.

```
[root@localhost signal]# cat /etc/audit/rules.d/audit.rules | grep docker -w /var/lib/docker/  -k docker 
[root@localhost signal]# auditctl -R /etc/audit/rules.d/audit.rules | grep docker 
[root@localhost signal]# auditctl -l | grep docker -w /var/lib/docker/ -p rwxa -k docker
```

> ![](./public_sys-resources/icon-note.gif) **ПРИМЕЧАНИЕ**:  
**-p \[r\|w\|x\|a]** и **-w** используются вместе для отслеживания изменений, связанных с операциями чтения, записи, исполнения, а также изменений атрибутов (например, изменений отметки времени) каталога. В этом случае любой файл или каталог в каталоге **/var/lib/docker** будет записан в файл **audit.log**. В результате в файл **audit.log** будет записано слишком много журналов, что серьезно отразится на загрузке памяти или процессора, занятых процессом auditd, а также на ОС. Например, журналы, подобные приведенным ниже, будут записываться в файл **/var/log/audit/audit.log**  каждый раз, когда будет выполняться команда  **ls /var/lib/docker/containers**.

```
type=SYSCALL msg=audit(1517656451.457:8097): arch=c000003e syscall=257 success=yes exit=3 a0=ffffffffffffff9c a1=1b955b0 a2=90800 a3=0 items=1 ppid=17821 pid=1925 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts6 ses=4 comm="ls" exe="/usr/bin/ls" subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key="docker"type=CWD msg=audit(1517656451.457:8097):  cwd="/root"type=PATH msg=audit(1517656451.457:8097): item=0 name="/var/lib/docker/containers" inode=1049112 dev=fd:00 mode=040700 ouid=0 ogid=0 rdev=00:00 obj=unconfined_u:object_r:container_var_lib_t:s0 objtype=NORMAL 
```

  

### Функция безопасности seccomp

Во время тестирования производительности контейнерной сети выяснилось, что производительность Docker ниже производительности пространства имен родного ядра. После включения функции seccomp системные вызовы (например, sendto) не выполняются через system\_call\_fastpath. Вместо этого инициируется tracesys, что значительно ухудшает производительность. Поэтому рекомендуется отключать функцию seccomp в сценариях работы контейнера, в которых службам требуется высокая производительность. Пример:

```
docker run -itd --security-opt seccomp=unconfined busybox:latest
```

### Запрет на операции изменения частного каталога демона Docker

Не изменяйте корневой каталог, используемый контейнером Docker (**/var/lib/docker** по умолчанию), каталог, используемый во время операции (**/run/docker** по умолчанию), или файлы или каталоги в данных двух каталогах. Запрещенные операции включают удаление файлов, добавление файлов, создание символических или жестких ссылок на каталоги или файлы, изменение атрибутов, разрешений или содержимого файлов. Если требуются какие-либо изменения, следует связаться с группой специалистов по контейнерам Euler для проверки.

### Меры предосторожности для обычных пользователей в сценарии с развертыванием большого количества контейнеров

Максимальное количество процессов, которые обычный пользователь может создать на хосте ОС, можно ограничить в файле **/etc/security/limits.d/20-nproc.conf**, который необходимо создать в системе. Аналогично максимальное количество процессов, которые может создать обычный пользователь в контейнере, определяется настройкой в файле **/etc/security/limits.d/20-nproc.conf** образа контейнера, как показано в следующем примере:

```
cat /etc/security/limits.conf 
*       soft    nproc   4096
```

Если во время развертывания обычным пользователем большого числа контейнеров из-за нехватки ресурсов передается ошибка, увеличьте значение **4096** в файле **/etc/security/limits.d/20-nproc.conf**.

Максимальное значение настраивается в соответствии с максимальной возможностью ядра, как показано в следующем примере:

```
[root@localhost ~]# sysctl -a | grep pid_max 
kernel.pid_max = 32768
```

## Настройка драйвера хранилища

Эта версия контейнерного движка Docker поддерживает два драйвера хранилища: overlay2 и devicemapper. Поскольку overlay2 обладает более высокой производительностью, чем devicemapper, рекомендуется в рабочей среде отдавать предпочтение именно ему.

### Настройка драйвера хранилища overlay2

#### Методы настройки

overlay2 является драйвером хранилища Docker по умолчанию. Для проверки и настройки драйвера можно использовать один из следующих способов:

- Проверка или настройка поля **storage-driver** в файле **/etc/docker/daemon.json**.
  
  ```
  cat /etc/docker/daemon.json
  {
      "storage-driver": "overlay2"
  }
  ```

- Проверка или настройка параметров запуска демона Docker в файле **/etc/sysconfig/docker-storage**.
  
  ```
  cat /etc/sysconfig/docker-storage 
  DOCKER_STORAGE_OPTIONS="--storage-driver=overlay2"
  ```

#### Меры предосторожности

- При выполнении операций управления жизненным циклом на некоторых контейнерах может появляться ошибка, сообщающая, что не найдена соответствующая корневая файловая система или исполняемый файл.

- Если для выполнения исполняемых файлов в контейнере настроена проверка работоспособности контейнера, возможно появление ошибки, которая вызовет сбой проверки.

- При использовании overlay2 в качестве драйвера graphdriver и при первом изменении файла образа в контейнере, изменение не будет выполнено, если размер файла больше размера оставшегося пространства системы. Даже при небольшом изменении весь файл копируется на верхний уровень. Если оставшегося пространства недостаточно, изменение не выполняется.

- По сравнению с обычными файловыми системами overlay2 имеет следующие отличия:
  
  - Версия ядра
    
    overlay2 совместима только с родным ядром 4.0 или более поздней версии. Рекомендуется использовать файловую систему Ext4.
  
  - Производительность процесса Copy-UP
    
    Изменение файлов на нижнем уровне запускает процесс репликации файлов на верхний уровень. Репликация блоков данных и процесс fsync занимают много времени.
  
  - Переименование каталога
    
    - Системный вызов для переименования разрешается, только если исходный путь и путь назначения находятся на одном объединенном уровне. В противном случае передается ошибка EXDEV.
    
    - В ядре версии 4.10 данная проблема исправлена функцией переименования каталога. Соответствующий параметр ядра — **CONFIG\_OVERLAY\_FS\_REDIRECT\_DIR**.
      
      При использовании драйвера overlay2 переименовать каталог файловой системы нельзя, поскольку соответствующая функция, сконфигурированная в файле **/sys/module/overlay/parameters/redirect\_dir**, отключена. Чтобы использовать эту функцию, необходимо вручную установить параметру **/sys/module/overlay/parameters/redirect\_dir** значение **Y**.
  
  - Отмена жесткой ссылки
    
    - Если в каталоге нижнего уровня есть несколько жестких ссылок, при записи данных на объединенный уровень запускается процесс Copy-UP, что приводит к отмене жестких ссылок.
    - Для исправления этой проблемы в ядре версии 4.13 введена функция индексации. Соответствующий параметр ядра — **CONFIG\_OVERLAY\_FS\_INDEX**. Обратите внимание, что этот параметр не поддерживает прямую совместимость и обновление в горячем режиме.
  
  - Изменения **st\_dev** и **st\_ino**
    
    После инициирования процесса Copy-UP можно просматривать только новые файлы на объединенном уровне и изменения индексных дескрипторов (inode). **attr** и **xattr** можно реплицировать, а **st\_dev** и **st\_ino** уникальны и не реплицируются. Таким образом, для проверки соответствующих изменений inode запускаются команды **stat** и **ls**.
  
  - Изменение fd
    
    Перед инициированием процесса Copy-UP можно получить дескриптор fd1, открывая любой файл в режиме только для чтения. После того, как процесс Copy-UP будет запущен, можно получить дескриптор fd2, открывая файл с таким же именем. Эти два дескриптора указывают на разные файлы. Данные, записанные в fd2, не отображаются в fd1.

#### Сценарии с ошибками

Если контейнер использует драйвер хранилища overlay2, это может привести к перезаписи точек монтирования.

  

#### Некорректный сценарий: перезаписанная точка монтирования

В некорректном контейнере находится точка монтирования в **/var/lib/docker/overlay2**.

```
[root@localhost ~]# mount -l | grep overlay 
overlay on /var/lib/docker/overlay2/844fd3bca8e616572935808061f009d106a8748dfd29a0a4025645457fa21785/merged type overlay (rw,relatime,seclabel,lowerdir=/var/lib/docker/overlay2/l/JL5PZQLNDCIBU3ZOG3LPPDBHIJ:/var/lib/docker/overlay2/l/ELRPYU4JJG4FDPRLZJCZZE4UO6,upperdir=/var/lib/docker/overlay2/844fd3bca8e616572935808061f009d106a8748dfd29a0a4025645457fa21785/diff,workdir=/var/lib/docker/overlay2/844fd3bca8e616572935808061f009d106a8748dfd29a0a4025645457fa21785/work) 
/dev/mapper/dm-root on /var/lib/docker/overlay2 type ext4 (rw,relatime,seclabel,data=ordered)
```

При выполнении некоторых команд Docker может произойти следующая ошибка:

```
[root@localhost ~]# docker rm 1348136d32
docker rm: Error response from daemon: driver "overlay2" failed to remove root filesystem for 1348136d32: error while removing /var/lib/docker/overlay2/844fd3bca8e616572935808061f009d106a8748dfd29a0a4025645457fa21785: invalid argument
```

То есть корневая файловая система (rootfs) соответствующего контейнера не найдена на хосте. Однако это не означает, что rootfs потеряна. Корневая файловая система перезаписана точкой монтирования **/var/lib/docker/overlay2**, службы продолжают корректно работать. Решение проблемы:

- Решение 1
  
  1. Проверьте graphdriver, используемый движком Docker, следующей командой:
     
     ```
     docker info | grep "Storage Driver"
     ```
     
       
  
  2. Выполните запрос текущей точки монтирования следующей командой:
     
     ```
     Devicemapper: mount -l | grep devicemapper 
     Overlay2: mount -l | grep overlay2
     ```
     
     Формат командного вывода: _A_ on _B_ type _C_ (_D_).
     
     - *A*: имя устройства блочного типа или **overlay**
     - _B_: точка монтирования
     - *C*: тип файловой системы
     - *D*: атрибут монтирования
  
  3. Выполните команду **umount** последовательно во всех точках монтирования (*B*) снизу вверх.
  
  4. Выполните команду **docker restart** на всех контейнерах или удалите все контейнеры.
  
  5. Выполните команду перезапуска Docker:
     
     ```
     systemctl restart docker
     ```

- Решение 2
  
  1. Выполните миграцию служб.
  2. Перезапустите узлы.

### Настройка драйвера хранилища devicemapper

Если необходимо использовать драйвер хранилища devicemapper движка Docker, проверьте или настройте драйвер одним из следующих способов:

- Проверка или настройка поля **storage-driver** в файле **/etc/docker/daemon.json**.
  
  ```
  cat /etc/docker/daemon.json
  {
      "storage-driver": "devicemapper"
  }
  ```

- Проверка или настройка параметров запуска демона Docker в файле **/etc/sysconfig/docker-storage**.
  
  ```
  cat /etc/sysconfig/docker-storage 
  DOCKER_STORAGE_OPTIONS="--storage-driver=devicemapper"
  ```

#### Меры предосторожности

- Для использования devicemapper требуется режим direct-lvm. Подробнее о методе настройки см. [https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#configure-direct-lvm-mode-for-production](https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#configure-direct-lvm-mode-for-production).

- Если при конфигурировании devicemapper не будет хватать памяти системы для автоматического увеличения емкости пула thinpool, отключите эту функцию.

- Не устанавливайте одновременно двум следующим параметрам в файле **/etc/lvm/profile/docker-thinpool.profile** значение **100**:
  
  ```
  activation {   
    thin_pool_autoextend_threshold=80   
    thin_pool_autoextend_percent=20 
  }
  ```

- При использовании драйвера devicemapper рекомендуется добавить параметры **--storage-opt dm.use\_deferred\_deletion=true** и **--storage-opt dm.use\_deferred\_removal=true** .

- В качестве файловой системы контейнера при использовании драйвера devicemapper рекомендуется Ext4. К конфигурационным параметрам демона Docker необходимо добавить **--storage-opt dm.fs=ext4**.

- Если графическим драйвером (graphdriver) является devicemapper, а файлы метаданных повреждены и не могут быть восстановлены, необходимо вручную восстановить файлы метаданных. Запрещается оперировать метаданными драйвера хранилища devicemapper в демоне Docker напрямую, а также незаконно изменять их.

- Если при использовании LVM-диспетчера devicemapper пул thinpool devicemapper будет поврежден по причине сбоя питания, невозможно будет обеспечить целостность данных или восстановить поврежденный thinpool. Поэтому thinpool необходимо заново скомпоновать.

**Меры предосторожности при переключении пула хранилища с драйвером devicemapper, когда на демоне Docker включена функция пространства имен пользователей**

- Как правило, во время запуска контейнера путем к файлу метаданных устройств является путь **/var/lib/docker/devicemapper/metadata/deviceset-metadata**.
- Если используются пространства имен пользователей, то путь к файлу метаданных устройств будет **/var/lib/docker/**_userNSUID.GID_**/devicemapper/metadata/deviceset-metadata**.
- Если при использовании драйвера хранилища devicemapper контейнер переключается между сценарием пространства имен пользователей и обычным сценарием, необходимо очистить содержимое **BaseDeviceUUID** в соответствующем файле метаданных устройств deviceset-metadata. В сценарии повторной компоновки или увеличения емкости пула thinpool также необходимо очистить содержимое **BaseDeviceUUID** в файле deviceset-metadata. В противном случае не удастся перезапустить службу Docker.

## Результат принудительного аннулирования фоновых процессов Docker

Цепь вызовов Docker длинная. Принудительное аннулирование фоновых процессов движка Docker (например, отправкой сигнала **kill -9**) может привести к несогласованности в состоянии данных. В этом разделе описываются некоторые проблемы, к которым может привести процесс принудительного аннулирования.

### Вероятность сохранения остаточных семафоров

Когда devicemapper используется в качестве драйвера graphdriver, процесс принудительного аннулирования может стать причиной сохранения остаточных семафоров. Docker создает семафоры при выполнении операций с драйвером devicemapper. Если процесс демона принудительно аннулируется перед освобождением ресурсов семафоров, может произойти сбой при освобождении. Максимально в один момент времени может произойти утечка одного семафора (сохранение семафора после закрытия процесса), и вероятность утечки низкая. Однако в ОС Linux предусмотрено верхнее предельное значение для семафоров. Когда количество утечек семафорных ресурсов достигает данного предельного значения, новые семафоры не создаются. В результате демон Docker невозможно запустить. Метод устранения проблемы:

1. Проверьте наличие остаточных семафорных ресурсов в системе.
   
   ```
   $ ipcs 
   ------ Message Queues -------- 
   key        msqid      owner      perms      used-bytes   messages 
   ------ Shared Memory Segments -------- 
   key        shmid      owner      perms      bytes      nattch     status 
   ------ Semaphore Arrays -------- 
   key        semid      owner      perms      nsems 
   0x0d4d3358 238977024  root       600        1 
   0x0d4d0ec9 270172161  root       600        1 
   0x0d4dc02e 281640962  root       600        1
   ```

2. Выполните команду **dmsetup**, чтобы проверить семафоры, созданные драйвером devicemapper. Набор семафоров — это подгруппа системных семафоров, запрошенных на предыдущем шаге.
   
   ```
   $ dmsetup udevcookies 
   ```

3. Проверьте верхнее предельное значение для семафоров ядра. В примере это четвертое в строке значение.
   
   ```
   $ cat /proc/sys/kernel/sem 
   250     32000   32      128
   ```
   
   Если количество остаточных семафоров на шаге 1 совпадает с верхним предельным значением семафоров на шаге 3, значит, это количество достигло верхнего предела. В этом случае демон Docker невозможно корректно запустить. Чтобы перезапустить Docker, увеличьте верхнее предельное значение, выполнив следующую команду:
   
   ```
   $ echo 250 32000  32  1024 > /proc/sys/kernel/sem
   ```
   
   Также можно вручную сбросить остаточные ресурсы семафоров devicemapper следующей командой. Далее описывается, как сбросить остаточные ресурсы семафоров devicemapper, примененных минуту назад.
   
   ```
   $ dmsetup udevcomplete_all 1 
   This operation will destroy all semaphores older than 1 minutes with keys that have a prefix 3405 (0xd4d). 
   Do you really want to continue? [y/n]: y 
   0 semaphores with keys prefixed by 3405 (0xd4d) destroyed. 0 skipped.
   ```

### Вероятность сохранения остаточных ресурсов NIC

При запуске контейнера в режиме моста принудительное аннулирование процесса может стать причиной сохранения остаточных ресурсов NIC. Когда Docker создает контейнер в режиме мостовой сети, на хосте создается пара устройств veths, а затем информация о ресурсах NIC сохраняется в базе данных. Если демон принудительно аннулируется до сохранения информации о ресурсах NIC в базе данных Docker, NIC не получает привязку к Docker и ресурс карты нельзя удалить во время следующего запуска, так как Docker удаляет неиспользуемые карты NIC из своей базы данных.

### Сбой перезапуска контейнера

Если процесс перехвата (hook) контейнера длится продолжительное время, и процесс containerd принудительно аннулируется во время запуска контейнера, возможен сбой запуска контейнера. В случае принудительного аннулирования containerd во время запуска контейнера возвращается ошибка, связанная с операцией запуска Docker. После перезапуска процесса containerd последний процесс запуска может все еще находиться в стадии выполнения команды **runc create** (исполнение определяемого пользователем процесса hook может занять много времени). Если для запуска контейнера повторно выполнить команду **docker start**, может появиться следующее сообщение об ошибке:

```
Error response from daemon: oci runtime error: container with id exists: xxxxxx
```

Эта ошибка вызвана текущим выполнением команды **runc create** на существующем (или создаваемом) контейнере. После завершения операции **runc create**, соответствующей первой операции запуска, команда **docker start** будет успешно выполнена.

Выполнение процесса hook не контролируется движком Docker. В этом случае, если контейнер перезапускается, процесс containerd может приостановиться при выполнении неизвестной программы hook. Однако данный риск можно предотвратить (несмотря на короткий период времени, в который был затронут процесс создания текущего контейнера).

- После завершения первой операции контейнер можно успешно запустить снова.
- Как правило, после сбоя запуска контейнера создается новый контейнер. Контейнер, запуск которого завершился сбоем, повторно не используется.

Данная проблема некоторым образом ограничивает реализацию сценариев.

### Сбой перезапуска службы Docker

Службу Docker невозможно корректно перезапустить из-за частого запуска в короткий промежуток времени. Служба Docker контролируется службой systemd. Если служба Docker перезапускается более пяти раз в течение 10 секунд, служба systemd обнаруживает некорректный процесс и отключает службу Docker. После чего Docker сможет ответить на команду перезапуска и корректно перезапуститься, только когда начнется следующий десятисекундный период.

## Результат отключения питания системы

Непредвиденное отключение питания системы или возникшая в системе критическая ошибка (паника системы) могут стать причиной несвоевременного обновления состояния демона Docker на диске. В результате демон Docker работает некорректно после перезапуска системы. Возможные проблемы:

- Перед отключением питания создается контейнер. После перезапуска контейнер не отображается выполнением команды **docker ps –a**, поскольку состояние файла контейнера на диске не обновлено. В результате демон не может получить информацию о состоянии контейнера после перезапуска.
- Перед отключением питания системы записывается файл. После перезапуска демона обнаруживается некорректный формат файла или неполное его содержимое. В результате происходит ошибка загрузки.
- Поскольку база данных Docker повреждается во время отключения питания, все файлы такой БД в **data-root** удаляются во время перезапуска узла. Поэтому следующая информация, созданная перед перезапуском, удаляется после перезапуска:
  - Сеть: ресурсы, созданные через сеть Docker, удаляются после перезапуска узла.
  
  - Том: ресурсы, созданные через том Docker, удаляются после перезапуска узла.
  
  - Структура кэш-памяти: информация о структуре кэш-памяти удаляется после перезапуска узла.
  
  - Метаданные, хранящиеся в containerd: воссоздаются при запуске контейнера. Поэтому такие метаданные удаляются при перезапуске узла.
    
    > ![](./public_sys-resources/icon-note.gif) **ПРИМЕЧАНИЕ**:  
Если планируется вручную сбросить данные и восстановить состояние среды, установите для переменной среды **DISABLE\_CRASH\_FILES\_DELETE** значение **true**, чтобы отключить функцию сброса файлов БД при перезапуске процесса демона по причине отключения питания.